rite shell scripts to a. Rename all files with *.jpg 
#!/bin/bash
for f in *.txt; 
do 
    mv -- "$f" "${f%.txt}.jpg"
done
-------
b. Delete the zero sized file

#!/bin/bash
echo "Enter any file name: "
read filenm
if [ -e $filenm ]
then
    echo $filenm" File exist"if [ -s $filenm ]
    then
        echo $filenm" File has size > 0"else
        rm $filenm
        echo $filenm" File is Deleted which has size = 0"
    fi
else
    echo "File not exist"
fi
----
Take an input file and remove identical lines (or duplicate lines from the file)

#!/bin/bash
echo "Enter File Name containing duplicate words:-"
read name
echo "Data In File $name:-" 
cat -n $name > 2.txt
cat 2.txt
echo "Sort Data"
sort -k2 2.txt
echo "Sort Data by Line Number:-"
sort -k2 2.txt | uniq -f1 | sort -k1
echo "File Unique Data:-"
sort -k2 2.txt | uniq -f1 | sort -k1 | cut -f2
----
Using switch case statement make a menu driven shell script program to perform various operations on files and directories

#!/bin/bash
echo " MENU "
echo " 1.List the files and directories "
echo " 2.Change the directory "
echo " 3.Create New Directory "
echo " 4.Remove Directory "
echo " 5.Show Files with Permission "
echo " Enter the choice "
read ch
case $ch in
        1)
                echo " The files and directories are "
                ls
                ;;
        2)
                echo " Changing the current directory "
                echo " Enter the directory "
                read direct
                cd $direct
                ;;
        3)
                echo " Enter Name for directory "
                read file1
                mkdir $file1
                echo " Directory created successfully "
                ls
                ;;
        4)
                echo " Enter Name for directory "
                read file
                rm -r $file
                echo " Directory removed successfully "
                ls
                ;;
        5)
                echo " Files Permission "
                ls -l
                ;;
esac
----
Implement Interprocess Communication using PIPE/Shared Memory/Message Passing

#include <stdio.h>				//Import Library 
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>


void processA(int);		//Create Function A
void processB(int);		//Create Function A

void processA(int writefd) //For Function A
{
    int len;			//Variable Declaration
    char buff[80];
    printf("Enter a string: ");
    fgets (buff,80,stdin);			//take input
    len=strlen(buff);
    if(buff[len-1]=='\n')		//if statement
    {
        len--;
    }
    write(writefd,buff,len);
}


void processB(int readfd)	//For Function B
{
    int n,i,j;				//Variable Declaration
    char str[80],temp;
    n=read(readfd,str,80);
    str[n]='\0';
    i=0;
    j=strlen(str)-1;
    while(i<j)				//while conditional loop for string 
    {
        temp=str[i];
        str[i]=str[j];
        str[j]=temp;
        i++;
        j--;
    }
    printf("Reversed string: %s\n",str);
}


int main(void) 			//Main Function
{
    int pipe1[2];		//Variable Declaration
    pid_t childpid;
    pipe(pipe1);
    childpid = fork();
    if (childpid==0)		//if else statement
    {
        close (pipe1[1]);
        processB (pipe1[0]);
    }
    else
    {
        close (pipe1[0]);
        processA (pipe1[1]);
    }
    return EXIT_SUCCESS;	
}
-----
FCFS Algorithm:-

Program:-

#include<stdio.h>
 
int main()
{
    int n,bt[20],wt[20],tat[20],avwt=0,avtat=0,i,j;
    printf("<----------Program for FCFS Algorithm---------->\n\n");
    printf("Enter total number of processes:");
    scanf("%d",&n);
 
    printf("\nEnter Process Burst Time\n");
    for(i=0;i<n;i++)
    {
        printf("P[%d]:",i+1);
        scanf("%d",&bt[i]);
    }
 
    wt[0]=0;    //waiting time for first process is 0
 
    //calculating waiting time
    for(i=1;i<n;i++)
    {
        wt[i]=0;
        for(j=0;j<i;j++)
            wt[i]+=bt[j];
    }
 
    printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time");
 
    //calculating turnaround time
    for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];
        avwt+=wt[i];
        avtat+=tat[i];
        printf("\nP[%d]\t\t%d\t\t%d\t\t%d",i+1,bt[i],wt[i],tat[i]);
    }
 
    avwt/=i;
    avtat/=i;
    printf("\n\nAverage Waiting Time is:%d",avwt);
    printf("\nAverage Turnaround Time is:%d",avtat);
 
    return 0;
}
----
SJF(Preemptive) Algorithm:-

Program:-

#include<iostream>
#include<algorithm>
using namespace std;

struct node{
    char pname;
    int btime;
    int atime;
    int restime=0;
    int ctime=0;
    int wtime=0;
}a[1000],b[1000],c[1000];

void insert(int n){
    int i;
    for(i=0;i<n;i++){
        cin>>a[i].pname;
        cin>>a[i].atime;
        cin>>a[i].btime;
        a[i].wtime=-a[i].atime+1;
    }
}

bool btimeSort(node a,node b){
    return a.btime < b.btime; 
}
bool btimeOppSort(node a,node b){
    if(a.btime!=b.btime)
        return a.btime > b.btime; 
    return a.atime < b.atime;
}
bool atimeSort(node a,node b){
    return a.atime < b.atime; 
}

int k=0,f=0,r=0;
void disp(int nop,int qt){
    int n=nop,q;
    sort(a,a+n,atimeSort);
    int ttime=0,i;
    int j,tArray[n];
    int alltime=0;
    bool moveLast=false;
    for(i=0;i<n;i++){
        alltime+=a[i].btime;
  //      cout<<"start is "<<a[i].pname<<" to "<<ttime<<"\n";
    }
    alltime+=a[0].atime;
    for(i=0;ttime<=alltime;){
        j=i;
        while(a[j].atime<=ttime&&j!=n){
     //       cout<<"less than atime is "<<a[j].pname<<" to "<<ttime<<"\n";
            b[r]=a[j];
            j++;
            r++;
        }
        if(r==f){
            c[k].pname='i';
            c[k].btime=a[j].atime-ttime;
            c[k].atime=ttime;
            ttime+=c[k].btime;
            k++;
            continue;
        }
        i=j;
        if(moveLast==true){
     //       cout<<"moving "<<b[f].pname<<" to "<<r<<"\n";
             sort(b+f,b+r,btimeSort);    
            // b[r]=b[f];
            // f++;
            // r++;
        }

        j=f;
        if(b[j].btime>qt){
            c[k]=b[j];
            c[k].btime=qt;
            k++;
            b[j].btime=b[j].btime-qt;
            ttime+=qt;  
            moveLast=true;
            for(q=0;q<n;q++){
                if(b[j].pname!=a[q].pname){
                    a[q].wtime+=qt;
                }
            }
        }
        else{
            c[k]=b[j];
            k++;
            f++;
            ttime+=b[j].btime;  
            moveLast=false;
            for(q=0;q<n;q++){
                if(b[j].pname!=a[q].pname){
                    a[q].wtime+=b[j].btime;
                }
            }
    //           cout<<"called for "<<b[j].pname<<" "<<b[j].btime<<"\n";
        }
        if(f==r&&i>=n)
        break;
    }
    tArray[i]=ttime;
    ttime+=a[i].btime;
    for(i=0;i<k-1;i++){
        if(c[i].pname==c[i+1].pname){
            c[i].btime+=c[i+1].btime;
            for(j=i+1;j<k-1;j++)
                c[j]=c[j+1];
            k--;
            i--;
        }
    }
    
    int rtime=0;
    for(j=0;j<n;j++){
        rtime=0;
        for(i=0;i<k;i++){
            if(c[i].pname==a[j].pname){
                a[j].restime=rtime;
                break;
            }
            rtime+=c[i].btime;
        }
    }

    float averageWaitingTime=0;
    float averageResponseTime=0;
    float averageTAT=0;
    
    cout<<"\nGantt Chart\n";
    rtime=0;
    for (i=0; i<k; i++){
        if(i!=k)
            cout<<"|  "<<'P'<< c[i].pname << "   "; 
        rtime+=c[i].btime;
        for(j=0;j<n;j++){
            if(a[j].pname==c[i].pname)
                a[j].ctime=rtime;
        } 
    }
    cout<<"\n";
    rtime=0;
    for (i=0; i<k+1; i++){
        cout << rtime << "\t";
        tArray[i]=rtime;
        rtime+=c[i].btime; 
    }

    cout<<"\n";
    cout<<"\n";
    cout<<"P.Name  Arrival\tBurst\tCT\tTAT\tWT\tRT\n";
    for (i=0; i<nop&&a[i].pname!='i'; i++){
        if(a[i].pname=='\0')
            break;
        cout <<'P'<< a[i].pname << "\t"; 
        cout << a[i].atime << "\t";
        cout << a[i].btime << "\t";
        cout << a[i].ctime << "\t"; 
        cout << a[i].wtime+a[i].ctime-rtime+a[i].btime << "\t"; 
        averageTAT+=a[i].wtime+a[i].ctime-rtime+a[i].btime;
        cout << a[i].wtime+a[i].ctime-rtime << "\t"; 
        averageWaitingTime+=a[i].wtime+a[i].ctime-rtime;
        cout << a[i].restime-a[i].atime << "\t";  
        averageResponseTime+=a[i].restime-a[i].atime;
        cout <<"\n"; 
    }

    cout<<"Average Response time: "<<(float)averageResponseTime/(float)n<<endl;
    cout<<"Average Waiting time: "<<(float)averageWaitingTime/(float)n<<endl;
    cout<<"Average TA time: "<<(float)averageTAT/(float)n<<endl;

}

int main(){
    int np,choice,i,qt;
    cout<<"<----------Program for SJF(Preemptive) Algorithm---------->\n\n";
    cout<<"Enter number of processes:-\n";
    cin>>np;
    cout<<"Enter process, ArrivalTime, BurstTime:-\n";
    insert(np);
    disp(np,1);
    return 0;
}
----
SJF(Non-Preemptive) Algorithm:-

Program:-

#include<iostream>
#include<algorithm>
using namespace std;

struct node{
    char pname[50];
    int btime;
    int atime;
}a[50];

void insert(int n){
    int i;
    for(i=0;i<n;i++){
        cin>>a[i].pname;
        cin>>a[i].atime;
        cin>>a[i].btime;
    }
}

bool btimeSort(node a,node b){
    return a.btime < b.btime; 
}

bool atimeSort(node a,node b){
    return a.atime < b.atime; 
}

void disp(int n){
    sort(a,a+n,btimeSort);
    sort(a,a+n,atimeSort);
    int ttime=0,i;
    int j,tArray[n];
    for(i=0;i<n;i++){
        j=i;
        while(a[j].atime<=ttime&&j!=n){
            j++;
        }
        sort(a+i,a+j,btimeSort);
        tArray[i]=ttime;
        ttime+=a[i].btime;
    }
    tArray[i] = ttime;

    float averageWaitingTime=0;
    float averageResponseTime=0;
    float averageTAT=0;
    cout<<"\n";
    cout<<"P.Name  AT\tBT\tCT\tTAT\tWT\tRT\n";
    for (i=0; i<n; i++){
        cout << a[i].pname << "\t"; 
        cout << a[i].atime << "\t";
        cout << a[i].btime << "\t";
        cout << tArray[i+1] << "\t"; 
        cout << tArray[i]-a[i].atime+a[i].btime << "\t"; 
        averageTAT+=tArray[i]-a[i].atime+a[i].btime;
        cout << tArray[i]-a[i].atime << "\t"; 
        averageWaitingTime+=tArray[i]-a[i].atime;
        cout << tArray[i]-a[i].atime << "\t";  
        averageResponseTime+=tArray[i]-a[i].atime;
        cout <<"\n"; 
    }
    cout<<"\n";
    cout<<"\nGantt Chart\n";
    for (i=0; i<n; i++){
        cout <<"|   "<< a[i].pname << "   "; 
    }
    cout<<"\n";
    for (i=0; i<n+1; i++){
        cout << tArray[i] << "\t"; 
    }
    cout<<"\n";
    cout<<"Average Response time: "<<(float)averageResponseTime/(float)n<<endl;
    cout<<"Average Waiting time: "<<(float)averageWaitingTime/(float)n<<endl;
    cout<<"Average TA time: "<<(float)averageTAT/(float)n<<endl;
}

int main(){
    int nop,choice,i;
    cout<<"<----------Program for SJF(Non-Preemptive) Algorithm---------->\n\n";
    cout<<"Enter number of processes:\n";
    cin>>nop;
    insert(nop);
    disp(nop);
    return 0;
}
----
Priority (Preemptive) Algorithm:-
#include<iostream>

 using namespace std;
int main()
{
    int a[10],b[10],x[10];
    int waiting[10],turnaround[10],completion[10],p[10];
    int i,j,smallest,count=0,time,n;
    double avg=0,tt=0,end;

   cout<<"\nEnter the number of Processes: ";
    cin>>n;
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter arrival time of process: ";
      cin>>a[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter burst time of process: ";
      cin>>b[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter priority of process: ";
      cin>>p[i];
    }
    for(i=0; i<n; i++)
        x[i]=b[i];

    p[9]=-1;
    for(time=0; count!=n; time++)
    {
        smallest=9;
        for(i=0; i<n; i++)
        {
            if(a[i]<=time && p[i]>p[smallest] && b[i]>0 )
                smallest=i;
        }
        b[smallest]--;

        if(b[smallest]==0)
        {
            count++;
            end=time+1;
            completion[smallest] = end;
            waiting[smallest] = end - a[smallest] - x[smallest];
            turnaround[smallest] = end - a[smallest];
        }
    }
     cout<<"Process"<<"\t"<< "burst-time"<<"\t"<<"arrival-time" <<"\t"<<"waiting-time" <<"\t"<<"turnaround-time"<< "\t"<<"completion-time"<<"\t"<<"Priority"<<endl;
    for(i=0; i<n; i++)
    {
         cout<<"p"<<i+1<<"\t\t"<<x[i]<<"\t\t"<<a[i]<<"\t\t"<<waiting[i]<<"\t\t"<<turnaround[i]<<"\t\t"<<completion[i]<<"\t\t"<<p[i]<<endl;
        avg = avg + waiting[i];
        tt = tt + turnaround[i];
    }
   cout<<"\n\nAverage waiting time ="<<avg/n;
    cout<<"  Average Turnaround time ="<<tt/n<<endl;
}

----
Priority (Non-Preemptive) Algorithm:-

Program:-

#include<iostream>

using namespace std;
int main()
{
    int a[10],b[10],x[10],pr[10]={0};
    int waiting[10],turnaround[10],completion[10];
    int i,j,smallest,count=0,time,n;
    double avg=0,tt=0,end;
    cout<<"<----------Program for Priority(Non-Preemptive) Algorithm---------->\n\n";
   cout<<"\nEnter the number of Processes:";
    cin>>n;
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter Arrival time of P["<<i<<"]:";
      cin>>a[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter Burst time of P["<<i<<"]:";
      cin>>b[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter Priority of P["<<i<<"]:";
      cin>>pr[i];
    }
    for(i=0;i<n;i++)
        x[i]=b[i];

    pr[9]=-1;
    for(time=0;count!=n;time++)
    {
        smallest=9;
        for(i=0;i<n;i++)
        {
            if(a[i]<=time && pr[i]>pr[smallest] && b[i]>0 )
                smallest=i;
        }
        time+=b[smallest]-1;
        b[smallest]=-1;
        count++;
        end=time+1;
        completion[smallest] = end;
        waiting[smallest] = end - a[smallest] - x[smallest];
        turnaround[smallest] = end - a[smallest];
    }
    cout<<"Process"<<"\t"<< "Burst time"<<"\t"<<"Arrival time" <<"\t"<<"Waiting time" <<"\t"<<"Turnaround time"<< "\t"<<"Completion time"<<"\t\t"<<"Priority"<<endl;
    for(i=0;i<n;i++)
    {
        cout<<"p"<<i+1<<"\t\t"<<x[i]<<"\t\t"<<a[i]<<"\t\t"<<waiting[i]<<"\t\t"<<turnaround[i]<<"\t\t"<<completion[i]<<"\t\t"<<pr[i]<<endl;
        avg = avg + waiting[i];
        tt = tt + turnaround[i];
    }
    cout<<"\n\nAverage waiting time:"<<avg/n;
    cout<<"\nAverage Turnaround time:"<<tt/n<<endl;
}
----
Round Robin Algorithm:-

Program:-


#include <iostream>

/*at = Arrival time,
bt = Burst time,
time_quantum= Quantum time
tat = Turn around time,
wt = Waiting time*/

using namespace std;

int main(){
	int i,n,time,remain,temps=0,time_quantum;

	int wt=0,tat=0;
	cout<<"<----------Program for Round Robin Algorithm---------->\n\n";
	cout<<"Enter the Total number of processes:"<<endl;
	cin>>n;

	remain=n;
	// assigning the number of process to remain variable

	int at[n];
	int bt[n];
	int rt[n];


	cout<<"Enter the Arrival time, Burst time:\n"<<endl;
	for(i=0;i<n;i++)
	{
	  cout<<"Arrival time for P["<<i+1<<"]"<<endl;
		cin>>at[i];
		cout<<"Burst time for P["<<i+1<<"]"<<endl;
		cin>>bt[i];
		rt[i]=bt[i];
	}

	cout<<"Enter the value of time QUANTUM:"<<endl;
	cin>>time_quantum;

	cout<<"\n\nProcess\tTurnaround Time\tWaiting Time\n\n";
	for(time=0,i=0;remain!=0;)
	{
		if(rt[i]<=time_quantum && rt[i]>0)
		{
			time += rt[i];
		
			rt[i]=0;
			temps=1;
		}

		else if(rt[i]>0)
		{
			rt[i] -= time_quantum;
		
			time += time_quantum;
		
		}

		if(rt[i]==0 && temps==1)
		{
			remain--;
			//Desplaying the result of wating, turn around time:
			printf("P[%d]\t\t %d\t %d\n",i+1,time-at[i],time-at[i]-bt[i]);
			cout<<endl;

			wt += time-at[i]-bt[i];
			tat += time-at[i];
			temps=0;
		}

		if(i == n-1)
			i=0;
		else if(at[i+1] <= time)
			i++;
		else
			i=0;
	}

	cout<<"Average waiting time "<<wt*1.0/n<<endl;
	cout<<"Average turn around time "<<tat*1.0/n<<endl;;

	return 0;
}
----
MENU DRIVEN:-
#include<iostream>
#include <algorithm>
#include <cstring>

using namespace std;


            typedef struct proccess					//Function For Preemptive SJF Algorithm
            {
                float at,bt,ct,ta,wt,btt;
                string pro_id;

            }Schedule;

            bool compare(Schedule a,Schedule b)
            {
                return a.at<b.at;
            }

            bool compare2(Schedule a,Schedule b)
            {
                return a.bt<b.bt;
            }



class scheduling				//Class Scheduling intilialized
{
public:
        void FCFS()					//Function For FCFS Algorithm
        {
            cout<<"\n For FCFS Algorithm\n";
            int n,bt[20],wt[20],tat[20],i,j;
            float avwt=0,avtat=0;
            cout<<"Enter total number of processes:";
            cin>>n;

            cout<<"\nEnter Process Burst Time\n";
            for(i=0;i<n;i++)
            {
                cout<<"P["<<i+1<<"]:";
                cin>>bt[i];
            }

            wt[0]=0;    //waiting time for first process is 0

            //calculating waiting time
            for(i=1;i<n;i++)
            {
                wt[i]=0;
                for(j=0;j<i;j++)
                    wt[i]+=bt[j];
            }

            cout<<"\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time";

            //calculating turnaround time
            for(i=0;i<n;i++)
            {
                tat[i]=bt[i]+wt[i];
                avwt+=wt[i];
                avtat+=tat[i];
                cout<<"\nP["<<i+1<<"]"<<"\t\t"<<bt[i]<<"\t\t"<<wt[i]<<"\t\t"<<tat[i];
            }

            avwt/=i;
            avtat/=i;
            cout<<"\nFor FCFS Algorithm";
            cout<<"\nAverage Waiting Time:"<<avwt;
            cout<<"\nAverage Turnaround Time:"<<avtat;
            cout<<"\n";
        }


        void Non_pre_SJF()				//Function For Non-Preemptive SJF Algorithm
        {
            cout<<"\nFor SJF Algorithm\n";
            int n,bt[20],wt[20],tat[20],i,j;
            float avwt=0,avtat=0;
            cout<<"Enter total number of processes:";
            cin>>n;

            cout<<"\nEnter Process Burst Time\n";
            for(i=0;i<n;i++)
            {
                cout<<"P["<<i+1<<"]:";
                cin>>bt[i];
            }

            for(i=0;i<n;i++)
              {
                 for(j=i+1;j<n;j++)
                  {
                        if(bt[i]>bt[j])
                        {

                              int temp=bt[i];
                              bt[i]=bt[j];
                              bt[j]=temp;
                        }
                  }
              }

            wt[0]=0;    //waiting time for first process is 0

            //calculating waiting time
            for(i=1;i<n;i++)
            {
                wt[i]=0;
                for(j=0;j<i;j++)
                    wt[i]+=bt[j];
            }

            cout<<"\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time";

            //calculating turnaround time
            for(i=0;i<n;i++)
            {
                tat[i]=bt[i]+wt[i];
                avwt+=wt[i];
                avtat+=tat[i];
                cout<<"\nP["<<i+1<<"]"<<"\t\t"<<bt[i]<<"\t\t"<<wt[i]<<"\t\t"<<tat[i];
            }

            avwt/=i;
            avtat/=i;
            cout<<"\nFor SJF Algorithm";
            cout<<"\nAverage Waiting Time:"<<avwt;
            cout<<"\nAverage Turnaround Time:"<<avtat;
            cout<<"\n";
        }


        void pre_SJF()										//Function For Preemptive SJF Algorithm
        {
             cout<<"\nFor SJF(Preemptive) Algorithm\n";
            Schedule pro[10];						//An array of Processes
            int n,i,j,pcom;								//n = number of processes, i= iteration variable
            

            cout<<"Enter the number of Process::";
            cin>>n;

            cout<<"Enter the Process arrival time & burst time :\n";

            for(i=0;i<n;i++)
            {
                cin>>pro[i].pro_id;
                cin>>pro[i].at;
                cin>>pro[i].bt;
                pro[i].btt=pro[i].bt;
            }

            sort(pro,pro+n,compare);


            i=0;
            pcom=0;
            while(pcom<n)
            {
                for(j=0;j<n;j++)
                {
                    if(pro[j].at>i)
                    break;
                }

                sort(pro,pro+j,compare2);


                if(j>0)
                {

                    for(j=0;j<n;j++)
                    {
                        if(pro[j].bt!=0)
                        break;
                    }
                    if(pro[j].at>i)

                    {
                        i=pro[j].at;

                    }
                    pro[j].ct=i+1;
                    pro[j].bt--;
                }
                i++;
                pcom=0;
                for(j=0;j<n;j++)
                {
                    if(pro[j].bt==0)
                    pcom++;
                }
            }

            cout<<"\n\nProID\tAtime\tBtime\tCtime\tTtime\tWtime\n";
            float twt=0,ttat=0;

            for(i=0;i<n;i++)
            {
                pro[i].ta=pro[i].ct-pro[i].at;
                pro[i].wt=pro[i].ta-pro[i].btt;


                cout<<pro[i].pro_id<<"\t"<<pro[i].at<<"\t"<<pro[i].btt<<"\t"<<pro[i].ct<<"\t"<<pro[i].ta<<"\t"<<pro[i].wt;
                twt=twt+pro[i].wt;
                ttat=ttat+pro[i].ta;
                cout<<endl;
            }

            cout<<"\nFor SJF(Preemptive) Algorithm\nAvg. Waiting Time:"<<twt/n<<"\nAvg. Turnaround Time:"<<ttat/n<<"\n";
        }

        void Round_Robin()							//Function For Round Robin Algorithm
        {
             cout<<"\nFor Round Robin Algorithm\n";
            int i,n,time,remain,temps=0,time_quantum;

                int wt=0,tat=0;

                cout<<"\nEnter the Total Number of Process:";
                cin>>n;

                remain=n;


                int at[n];
                int bt[n];
                int rt[n];
                for(i=0;i<n;i++)
                {
                    cout<<"\n\n"<<"Arrival time for Process "<<i+1<<":";
                    cin>>at[i];
                    cout<<"Burst time for process "<<i+1<<":";
                    cin>>bt[i];
                    rt[i]=bt[i];
                }

                cout<<"\nEnter QUANTUM Time"<<":";
                cin>>time_quantum;

                cout<<"\n\nProcess\t \tBurst Time\t \tTurnaround Time\t \tWaiting Time\n\n";
                for(time=0,i=0;remain!=0;)
                {
                    if(rt[i]<=time_quantum && rt[i]>0)
                    {
                        time += rt[i];

                        rt[i]=0;
                        temps=1;
                    }

                    else if(rt[i]>0)
                    {
                        rt[i] -= time_quantum;

                        time += time_quantum;

                    }

                    if(rt[i]==0 && temps==1)
                    {
                        remain--;

                        printf("Process %d \t \t%d\t \t%d\t \t\t%d\n",i+1,bt[i],time-at[i],time-at[i]-bt[i]);
                        cout<<endl;

                        wt += time-at[i]-bt[i];
                        tat += time-at[i];
                        temps=0;
                    }



                    if(i == n-1)
                        i=0;
                    else if(at[i+1] <= time)
                        i++;
                    else
                        i=0;
                }

                cout<<"\nFor Round Robin Algorithm";
                cout<<"\nTotal Waiting Time:"<<wt;
                cout<<"\nAverage Waiting Time "<<wt*1.0/n<<endl;
                cout<<"\nTotal Turn Around Time:"<<tat;
                cout<<"\nAverage Turn Around Time "<<tat*1.0/n<<endl;

        }//end of RR


        void Priority()								//Function For Priority Algorithm
        {
             cout<<"\nPriority\n";
                int a[10],b[10],x[10];
                int waiting[10],turnaround[10],completion[10],p[10];
                int i,j,smallest,count=0,time,n;
                double avg=0,tt=0,end;

                cout<<"\nEnter the number of Processes: ";
                cin>>n;
                for(i=0;i<n;i++)
                {
                  cout<<"\nEnter arrival time of process["<<i+1<<"]:";
                  cin>>a[i];
                }
                for(i=0;i<n;i++)
                {
                  cout<<"\nEnter burst time of process["<<i+1<<"]:";
                  cin>>b[i];
                }
                for(i=0;i<n;i++)
                {
                  cout<<"\nEnter priority of process["<<i+1<<"]:";
                  cin>>p[i];
                }
                for(i=0; i<n; i++)
                    x[i]=b[i];

                p[9]=-1;
                for(time=0; count!=n; time++)
                {
                    smallest=9;
                    for(i=0; i<n; i++)
                    {
                        if(a[i]<=time && p[i]>p[smallest] && b[i]>0 )
                            smallest=i;
                    }
                    b[smallest]--;

                    if(b[smallest]==0)
                    {
                        count++;
                        end=time+1;
                        completion[smallest] = end;
                        waiting[smallest] = end - a[smallest] - x[smallest];
                        turnaround[smallest] = end - a[smallest];
                    }
                }
                cout<<"\nPriority Scheduling";
                cout<<"\nProcess"<<"\t"<< " Burst-Time"<<"\t"<<" Arrival Time" <<"\t"<<" Waiting Time" <<"\t"<<" Turnaround Time"<< "\t"<<"Completion Time  "<<"\t"<<"  Priority"<<endl;
                for(i=0; i<n; i++)
                {
                     cout<<"p"<<i+1<<"\t\t"<<x[i]<<"\t\t"<<a[i]<<"\t\t"<<waiting[i]<<"\t\t"<<turnaround[i]<<"\t\t\t"<<completion[i]<<"\t\t  "<<p[i]<<endl;
                     avg = avg + waiting[i];
                     tt = tt + turnaround[i];
                }
               
                cout<<"\n\nAverage waiting time:"<<avg/n;
                cout<<"\nAverage Turnaround time:"<<tt/n<<endl;
       

        }

};

int main()
{
    int ch;
    scheduling s;

    do
    {
        cout<<"\n<----------Process Scheduling Algorithm---------->";
        cout<<"\n1.FCFS\n2.SJF(Non-Preemptive)\n3.SJF(Preemptive)\n4.Priority(Non-Preemptive)\n5.Round Robin\n6.Exit\n\nEnter Your Choice:";
        cin>>ch;

        switch(ch)
        {
            case 1:         s.FCFS();
                            break;

            case 2:         s.Non_pre_SJF();
                            break;

            case 3:         s.pre_SJF();
                            break;

            case 4:         s.Priority();
                            break;

            case 5:         s.Round_Robin();
                            break;

            case 6:       
                            exit(0);
        }
    }while(ch!=6);

    return 0;
}
----
// Banker's Algorithm
#include <iostream>
using namespace std;

int* grant_req(int m,int avail[])
{
			int req[m],flag=0;
			cout<<"Enter resource request:\n";
 			for(int j=0;j<m;j++)
 				cin>>req[j];
 			
			cout<<"\nAvailable resources:\n";
 			for(int j=0;j<m;j++)
 				cout<<avail[j];
 			cout<<"\n";	
 			
			for (int j = 0; j < m; j++) 
			{
            	if (req[j] > avail[j])
				{
            		flag++;
            		break;
          		}
        	}
        	if(flag!=0)
        		cout<<"Request denied due to insufficient resources.\n";
        	else
        		cout<<"Request granted..!!\n";
        	
        return req;
}
		
int main()
{
    // P0, P1, P2, P3, P4 are the Process names here
  
  int n, m, i, j, k;
  cout<<"<----------Banker's Alogrithm---------->\n\n";
  cout<<"Enter no of processes(n) :";
  cin>>n;
  cout<<"Enter no of resources(m) :";
  cin>>m;
  int alloc[n][m] ;
  int max[n][m];
  int avail[m]; 
 
 	for( i=0;i<n;i++){
	 cout<<"Enter allocated instances for process P"<<i+1<<" :\n";
 		for( j=0;j<m;j++){
 			cin>>alloc[i][j];
		 }
	}
	cout<<endl;
	for( i=0;i<n;i++){
	 cout<<"Enter maximum instances for process P"<<i+1<<" :\n";
 		for( j=0;j<m;j++){
 			cin>>max[i][j];
		 }
	}
	
	
	 cout<<"Enter available instances:\n";
 		for( j=0;j<m;j++){
 			cin>>avail[j];
		 }
	cout<<endl;
  
  int ch,cnt=0;
  	cout<<"Do you want to make request for resorces(1/0)?\n";
  	cin>>ch;
  	cout<<"Requesting process no.:";
  	cin>>cnt;
  	if(ch==1)
  	{
		int*req=grant_req(m,avail);
  		for (int j = 0; j < m; j++)
	    {
			alloc[cnt-1][j]=alloc[cnt-1][j]+req[j];
	        avail[j]=avail[j]-req[j];
		}	
	}
	cout<<"\nNow available resources are :\n";
 	for(int j=0;j<m;j++)
 		cout<<avail[j]<<"\t"; 
 		
  int f[n]={0}, ans[n]={0}, ind = 0;
  /*for (k = 0; k < n; k++) {
    f[k] = 0;
  }*/
  //need matrix
  int need[n][m];
  for (i = 0; i < n; i++) {
    for (j = 0; j < m; j++)
      need[i][j] = max[i][j] - alloc[i][j];
  }
  
 cout<<"\n\nNeed Matrix :\n\n";
			  cout<<"\t";
			  for(i=0;i<m;i++)
			  {
			  	cout<<"R"<<i+1<<"\t";
			  }
			  cout<<endl;
			  for (i = 0; i < n; i++) {
			  	cout<<"P"<<i+1<<"\t";
			    for (j = 0; j < m; j++)
			      cout<<need[i][j]<<"\t"; 
			    cout<<"\n";
			  }
  
  int y = 0;
  for (k = 0; k < n; k++) {
    for (i = 0; i < n; i++) {
      if (f[i] == 0) {
  
        int flag = 0;
        for (j = 0; j < m; j++) {
          if (need[i][j] > avail[j]){
            flag = 1;
            break;
          }
        }
  
        if (flag == 0) {
          ans[ind++] = i;
          for (y = 0; y < m; y++)
            avail[y] += alloc[i][y];
          f[i] = 1;
        }
      }
    }
  }
  
	cout << "Following is the SAFE Sequence" << endl;
	for (i = 0; i < n - 1; i++)
		cout << " P" << ans[i] << " ->";
	cout << " P" << ans[n - 1] <<endl;
  
  	//else
  	//	exit(0);
  	cout<<"\nFinally available resources are :\n";
 	for(int j=0;j<m;j++)
 		cout<<avail[j]<<"\t";
    
}
----
Barber Program:-


#include <iostream>
#include <cstdlib>
#include <pthread.h>
#include <sstream>
#include <stdio.h>
#include <semaphore.h>
#include <mutex>

using namespace std;

//initialize the waiting room - max 25 customers
int waitingRoom[25];

//make the first index 0 for fill and use
//this tells where in the waiting room to put and remove people from
int addToLine = 0;
int removeFromLine  = 0;

//this semaphore is for the waiting room chairs.
//there should be as many resources as there are chairs
sem_t emptyChairs;

//there should be a semaphore for full chairs
//it should start at 0
sem_t fullChairs;

//this is a mutex lock for the waiting room
pthread_mutex_t waitMutex = PTHREAD_MUTEX_INITIALIZER;


//this is for the cout function. there should only be one (mutex).
//it makes cout legible
pthread_mutex_t coutMutex = PTHREAD_MUTEX_INITIALIZER;

//create struct to pass to thread functions
struct thread_details{
    //the thread id
    int threadID;

    //the total number of threads
    int totalCustomers;
};

//join the line
void joinLine(int id){
    //add that thread id to the line
    waitingRoom[addToLine] = id;

    //increment fill
    addToLine++;

}

//get a haircut
int getHaircut(){

    // this person is getting a haircut
    int id = waitingRoom[removeFromLine];

    //increment use
    removeFromLine++;

    //return the user who got the haircut
    return id;

}

void *GoToWork(void *customer_info){

    struct thread_details *p = (struct thread_details*) customer_info;

    //the barber is always sleeping at first
    pthread_mutex_lock(&coutMutex);
    cout << "The barber is sleeping. \n";
    pthread_mutex_unlock(&coutMutex);

    //for every customer, be in this loop
    for(int i = 0; i < p->totalCustomers; i++){

        //and wait for someone to show up
        sem_wait(&fullChairs);

        pthread_mutex_lock(&waitMutex);

        int customerID = getHaircut();

        //then get their hair cut hair
        pthread_mutex_lock(&coutMutex);
        cout << "The barber is cutting hair. \n";
        pthread_mutex_unlock(&coutMutex);

        pthread_mutex_unlock(&waitMutex);

        //which frees up a chair
        sem_post(&emptyChairs);

        //and that customer leaves
        pthread_mutex_lock(&coutMutex);
        cout << "Customer " << customerID << " is leaving the barber shop. \n";
        pthread_mutex_unlock(&coutMutex);

        //if there is a full chair
        int numFullChairs;
        sem_getvalue(&fullChairs, &numFullChairs);
        if(numFullChairs == 0){
            //the barber is sleeping
            pthread_mutex_lock(&coutMutex);
            cout << "The barber is sleeping. \n";
            pthread_mutex_unlock(&coutMutex);
        }
    }

    return NULL;
}


void *VisitBarber(void *customer_info){
    //*p is a pointer to this thread_details
    struct thread_details *p = (struct thread_details*) customer_info;
    pthread_mutex_lock(&coutMutex);
    cout << "Customer " << p->threadID <<" arrived at the barber shop.\n";
    pthread_mutex_unlock(&coutMutex);


    //if you can, take a seat
    sem_wait(&emptyChairs);  //empty chairs decreases by one

    //now add the user to the waiting room
    pthread_mutex_lock(&waitMutex);
    joinLine(p->threadID);

    pthread_mutex_lock(&coutMutex);
    cout << "Customer " << p->threadID << " took a seat in the waiting room.\n";
    pthread_mutex_unlock(&coutMutex);


    pthread_mutex_unlock(&waitMutex);
    sem_post(&fullChairs);

    int numFullChairs;
    sem_getvalue(&fullChairs, &numFullChairs);

    //if nobody is in the waiting room, wake up the barber
    if(numFullChairs == 1){
        pthread_mutex_lock(&coutMutex);
        cout << "Customer " << p->threadID << " woke up the barber. \n";
        pthread_mutex_unlock(&coutMutex);
    }

    return NULL;
}



int main() {


    //introduce the program
    cout << "<----------Welcome to the barber shop!---------->\n";

    //declare customers - 26 so it enters the while loop to get input
    int customerCount = 26;

    //get the number of customers - must be between 0 and 25
    while (customerCount > 25 || customerCount <= 0) {
        cout << "How many customers are there?\n"
                "There must be between 0 and 25 customers.\n";
        cin >> customerCount;

        //if the customercount is still invalid
        if (customerCount > 25 || customerCount < 0) {
            cout << "Sorry, you entered ";
            cout << customerCount;
            cout << " which is not between 0 and 25.\n";
        }
    }

    //declare waiting chairs
    int numChairs;
    cout << "How many chairs are there in the waiting room? \n";
    cin >> numChairs;

    //this semaphor is for the empty waiting room chairs.
    // there should be as many resources as there are chairs
    sem_init(&emptyChairs, 0, numChairs);

    //this semaphor is for the full waiting room chairs.
    sem_init(&fullChairs, 0, 0);

    //create thread ids
    pthread_t *threads = new pthread_t[customerCount];
    pthread_t barberThread;

    //create an int to determine if thread creation was successful
    int errorCheck;

    //create thread attributes
    pthread_attr_t attribute;

    //status of the thread
    void *status;

    //initialize and set thread joinable
    pthread_attr_init(&attribute);
    pthread_attr_setdetachstate(&attribute, PTHREAD_CREATE_JOINABLE);

    //create an array of structs to pass to threads
    thread_details *allThreads = new thread_details[customerCount];

    //create struct to pass to barber thread
    thread_details *barberInfo;

    thread_details tempStruct;
    tempStruct.totalCustomers = customerCount;
    tempStruct.threadID = 666; //a random id so I can use this struct

    //set up a pointer to point to it
    barberInfo = &tempStruct;

    //create barber thread
    pthread_create(&barberThread, &attribute, &GoToWork, (void *) barberInfo);


    //create customer threads
    for (int i = 0; i < customerCount; i++) {
        //create struct to pass info to VisitBarber
        allThreads[i].totalCustomers = customerCount;
        allThreads[i].threadID = i;

        //create a pointer to be sent to the thread
        thread_details *tempThread;

        //assign pointer to the correct struct in allThreads
        tempThread = &allThreads[i];

        //thread creation = leaving for the barber shop
        pthread_mutex_lock(&coutMutex);
        cout << "Customer " << i << " is leaving for the barber shop.\n";
        pthread_mutex_unlock(&coutMutex);

        //create the thread
        errorCheck = pthread_create(&threads[i], &attribute, &VisitBarber, (void *)tempThread);

        //check that the threads were created
        if (errorCheck) {
            cout << "Error: unable to create thread " << errorCheck << endl;
            exit(-1);
        }
    }

    //free the attribute and wait for other threads
    pthread_attr_destroy(&attribute);

    //make an int for results
    int results;

    //join the threads
    for (int i = 0; i < customerCount; i++){
        //this waits for all the results to be completed
        results = pthread_join(threads[i], &status);

        if (results){
            cout << "Error:unable to join," << results << endl;
            exit(-1);
        }

    }

    //tell the user the program is over.
    cout << "The barber is going home for the day. " << endl;

    //clear things out and end!
    cout.flush();
    pthread_exit(NULL);

}
----
Barber Program C:-
The Sleeping Barber
*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

void barber();   // barber thread function
void customer(); //customer thread function
                               
sem_t seatMutex;        // Semaphore for the waiting room
sem_t customers;        // Semaphore for customers currently in the waiting room ready to be served
sem_t smfBarber;        // Semaphore for the barber

int runningTime;        // Total time in seconds that the main thread will work
int numberOfFreeSeats;  // Capacity of the waiting room
int customersCount;     // Number of customers in the program that will come to the shop
int customerWait;       // Maximum time a customer would wait to come again to the shop
int getHCn;             // Number of customers who get haircut

pthread_t barberThread;           // Barber's thread
pthread_t customersThreads[20];   // An array of customer threads with max size of 20 

// Main method of the code                    
int main() {

    printf("Enter the running time of the program: ");
    scanf("%d",&runningTime);
    printf("Enter the number of free seats: ");
    scanf("%d",&numberOfFreeSeats);
    printf("Enter the customers count: ");
    scanf("%d",&customersCount);
    printf("Enter the maximun waiting time for the customer to come again: ");
    scanf("%d",&customerWait);
    
    getHCn = 0;   
   
    printf("\nProgram is beginning\n\n");
   
    // Initializing semaphores:
    // zero indicates that this semaphore is not allowed to be shared between processes, 1 is an initial value
    sem_init(&seatMutex,0,1); // the initial value is 1 because we need to allow only one thread to access
    sem_init(&customers,0,0);
    sem_init(&smfBarber,0,0);
   
    // Creating barber thread:
    pthread_create(&barberThread, NULL, barber, NULL); // barber is the function which the thread will start at
    printf("Barber has been created.\n");
    
    // Creating customers threads:
    for (int i = 0; i < customersCount; i++){
	   pthread_create(&customersThreads[i], NULL, customer, NULL); // customer is the function which the thread will start at
	   printf("Customer %u has been created.\n",customersThreads[i]);
    }
   
    // stop the main thread in order to run the other threads
    sleep(runningTime);
     
    printf("\n\nEnd of the day :)\n");
    printf("%d out of %d customers get haircut.",getHCn,customersCount);
    exit(0);
}

// barber thread function:
void barber() {
    int workingTime;    // Will be generated randomly to indicate the time
                    // that the barber will take to cut a customer's hair

    while(1) {
        //===== ENTRY SECTION =====//
       
        // acquire customers to wait for a customer 
	    sem_wait(&customers);
        // acquire seatMutex to access seats count  
	    sem_wait(&seatMutex);

	    //===== CRITICAL SECTION =====//
	  
        // increase the number of free seats
	    numberOfFreeSeats += 1;
	  
	    // generate random time between 1-5 seconds for the period of haircut.  
	    workingTime = (rand() % 5) + 1;
	    printf("Barber took a new customer, and he will take %d seconds for haircut.\n",workingTime);
	  
	    printf("\tNumber of free seats: %d\n",numberOfFreeSeats);
	    //===== EXIT SECTION =====//
	  
        // signal to customer which mean barber is ready  
	    sem_post(&smfBarber);
        // release lock on seat count 
	    sem_post(&seatMutex);
   	    sleep(workingTime);
    } 
}

// customer thread function:
void customer() {
    int waitingTime;
    int notEnd = 1;
    while(notEnd == 1) {
	    //===== ENTRY SECTION =====//
	    
        // acquire seatMutex to access seats count  
	    sem_wait(&seatMutex);
	    
	    
        // when there are no free seats 
	    if(numberOfFreeSeats <= 0){
	      
		    //===== EXIT SECTION =====//
		  
	        // generate random time for waiting until next try
	        waitingTime = (rand() % customerWait) + 1;
		    printf("Customer %u left without haircut, and will come back after %d seconds to try again.\n", pthread_self(),waitingTime);
		    sem_post(&seatMutex); // release the semaphore
		    
	        sleep(waitingTime);
	    }
	  
	  
        // when there are free seats 
	    else{
		  
		    //===== CRITICAL SECTION =====//
		   
            // decrease the number of free seats 
		    numberOfFreeSeats -= 1;
		    printf("Customer %u is waiting.\n",pthread_self());
		    printf("\tNumber of free seats: %d\n",numberOfFreeSeats);
		   
		    //===== EXIT SECTION =====//
		    
            // customer is ready 
		    sem_post(&customers);
            // release seatMutex lock on seat count 
		    sem_post(&seatMutex);
            // wait for barber 
		    sem_wait(&smfBarber);
            // get haircut 
		    printf("Customer %u get a haircut :)\n",pthread_self());
		    // the customer thread will end 
		    notEnd = 0;
		    // increse the number of customers who get haircut
		    getHCn += 1;
	    }
      
     }
}
----
page replacement algorithm
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void FIFO(){
	int p,f,n,i,pf=0,ph=0,j;
	char* str,*frame;
	printf("Enter the frame size : ");
	scanf("%d",&f);
	printf("Enter the string size : ");
	scanf("%d",&n);
	str=(char*)malloc(n*sizeof(char));
	frame=(char*)malloc(f*sizeof(char));
	for(i=0;i<f;i++) frame[i]=' ';
	printf("Enter the string : ");
	scanf("%s",str);
	p=0;
	for(i=0;i<f;i++) printf("%d",i+1);
	printf("\n\n");
	for(i=0;i<n;i++){
		if(strchr(frame,str[i])==NULL){
			pf++;
			frame[p]=str[i];
			p=(p+1)%f;
		}else{
			ph++;
		}
		for(j=0;j<f;j++){
			printf("%c",frame[j]);
		}
		printf("\n");
	}
	printf("Page Fault : %d",pf);
	printf("Page Hit : %d",ph);
}

char* substr(char* str,int index,int length){
	if(index>=strlen(str)||index+length>strlen(str)){
		return "";
	}
	char* chr,*ch;
	chr=(char*)malloc(strlen(str)*sizeof(char));
	strcpy(chr,str);
	chr=chr+index;
	ch=chr+length;
	*ch='\0';
	return chr;
}

void LRU(){
	int f,n,i,j,s,e,pf=0,ph=0;
	s=e=-1;
	char *frame,*string;
	printf("Enter the frame size : ");
	scanf("%d",&f);
	printf("Enter the string size : ");
	scanf("%d",&n);
	frame=(char*)malloc(f*sizeof(char));
	string=(char*)malloc(n*sizeof(char));
	for(i=0;i<f;i++) frame[i]=' ';
	printf("Enter the string : ");
	scanf("%s",string);
	for(i=0;i<n;i++){
		if(strchr(frame,string[i])==NULL){
			
			//frame=string[i]+substr(frame,1,f-1);
			strcpy(frame,strcat(substr(string,i,1),substr(frame,0,f-1)));
			pf++;
		}else{
			
			int x=(int)(strchr(frame,string[i])-frame);
			
			//frame=string[i] + substr(frame,0,x) + substr(frame,x+1,f-x-1);
			//*frame=string[i];
			
			/*frame[0]=string[i];
			frame=substr(frame,0,1);
			strcat(frame,substr(frame,0,x));
			strcat(frame,substr(frame,x+1,f-x-1));*/
			strcpy(frame,strcat(strcat(substr(frame,x,1),substr(frame,0,x)),substr(frame,x+1,f-1-x)));
			
			ph++;
		}
		printf("%s\n",frame);
	}
	printf("Page Fault : %d",pf);
	printf("Page Hit : %d",ph);
}

void OPT(){
	int f,n,i,max,j,pf=0,ph=0;
	char *frame,*string;
	printf("Enter the frame size : ");
	scanf("%d",&f);
	printf("Enter the string size : ");
	scanf("%d",&n);
	frame=(char*)malloc(f*sizeof(char));
	string=(char*)malloc(n*sizeof(char));
	for(i=0;i<f;i++) frame[i]=' ';
	printf("Enter the string : ");
	scanf("%s",string);
	for(i=0;i<n;i++){
		if(strchr(frame,string[i])==NULL){
			pf++;
			max=0;
			int p,q;
			for(j=0;j<f;j++){
				char* sub=strchr(string+i+1,frame[j]);
				p=(int)(strchr(string+i+1,frame[j])-string);
				if(sub==NULL){
					q=j;
					break;
				}else if(p>max){
					//printf("%d ",sub);
					max=p;
					q=j;
				}
			}
			//printf("\n");
			frame[q]=string[i];
		}else{
			ph++;
		}
		printf("%s\n",frame);
	}
	printf("Page Fault : %d",pf);
	printf("Page Hit : %d",ph);
}

void main(){
	char ch;
	printf("<----------Page Replacement Algorithms---------->\n");
	printf("Select Replacement Algorithm:-\n1.FIFO\n2.LRU\n3.OPTIMAL\n\nEnter Your Choice : ");
	scanf("%c",&ch);
	if(ch=='1'){
		FIFO();
	}else if(ch=='2'){
		LRU();
	}else if(ch=='3'){
		OPT();
	}else{
		printf("Invalid choice");
	}
}
----



