rite shell scripts to a. Rename all files with *.jpg 
#!/bin/bash
for f in *.txt; 
do 
    mv -- "$f" "${f%.txt}.jpg"
done
-------
b. Delete the zero sized file

#! /bin/bash

# Taking directory name as input from user
echo -n "Enter name of the directory : "
read directory_name

# If directory exists it will print 
# Directory exits 
# and remove the zero-sized files.
# Or if directory doesn't exists it will print 
# Directory does not exists.
if [ -d "$directory_name" ];
then
    echo "Directory exist"
        for i in `find $directory_name -size 0`
        do
            rm $i    
            echo "Zero-sized files are Successfully deleted"    
        done
else
    echo "Directory does not exist"

fi
----
Take an input file and remove identical lines (or duplicate lines from the file)

#!/bin/bash
echo "Enter File Name containing duplicate words:-"
read name
echo "Data In File $name:-" 
cat -n $name > 2.txt
cat 2.txt
echo "Sort Data"
sort -k2 2.txt
echo "Sort Data by Line Number:-"
sort -k2 2.txt | uniq -f1 | sort -k1
echo "File Unique Data:-"
sort -k2 2.txt | uniq -f1 | sort -k1 | cut -f2
----
Using switch case statement make a menu driven shell script program to perform various operations on files and directories

#!/bin/bash
echo " MENU "
echo " 1.List the files and directories "
echo " 2.Change the directory "
echo " 3.Create New Directory "
echo " 4.Remove Directory "
echo " 5.Show Files with Permission "
echo " Enter the choice "
read ch
case $ch in
        1)
                echo " The files and directories are "
                ls
                ;;
        2)
                echo " Changing the current directory "
                echo " Enter the directory "
                read direct
                cd $direct
                ;;
        3)
                echo " Enter Name for directory "
                read file1
                mkdir $file1
                echo " Directory created successfully "
                ls
                ;;
        4)
                echo " Enter Name for directory "
                read file
                rm -r $file
                echo " Directory removed successfully "
                ls
                ;;
        5)
                echo " Files Permission "
                ls -l
                ;;
esac
----
Implement Interprocess Communication using PIPE/Shared Memory/Message Passing

#include <stdio.h>				//Import Library 
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>


void processA(int);		//Create Function A
void processB(int);		//Create Function A

void processA(int writefd) //For Function A
{
    int len;			//Variable Declaration
    char buff[80];
    printf("Enter a string: ");
    fgets (buff,80,stdin);			//take input
    len=strlen(buff);
    if(buff[len-1]=='\n')		//if statement
    {
        len--;
    }
    write(writefd,buff,len);
}


void processB(int readfd)	//For Function B
{
    int n,i,j;				//Variable Declaration
    char str[80],temp;
    n=read(readfd,str,80);
    str[n]='\0';
    i=0;
    j=strlen(str)-1;
    while(i<j)				//while conditional loop for string 
    {
        temp=str[i];
        str[i]=str[j];
        str[j]=temp;
        i++;
        j--;
    }
    printf("Reversed string: %s\n",str);
}


int main(void) 			//Main Function
{
    int pipe1[2];		//Variable Declaration
    pid_t childpid;
    pipe(pipe1);
    childpid = fork();
    if (childpid==0)		//if else statement
    {
        close (pipe1[1]);
        processB (pipe1[0]);
    }
    else
    {
        close (pipe1[0]);
        processA (pipe1[1]);
    }
    return EXIT_SUCCESS;	
}
-----
FCFS Algorithm:-

Program:-

#include<stdio.h>
 
int main()
{
    int n,bt[20],wt[20],tat[20],avwt=0,avtat=0,i,j;
    printf("<----------Program for FCFS Algorithm---------->\n\n");
    printf("Enter total number of processes:");
    scanf("%d",&n);
 
    printf("\nEnter Process Burst Time\n");
    for(i=0;i<n;i++)
    {
        printf("P[%d]:",i+1);
        scanf("%d",&bt[i]);
    }
 
    wt[0]=0;    //waiting time for first process is 0
 
    //calculating waiting time
    for(i=1;i<n;i++)
    {
        wt[i]=0;
        for(j=0;j<i;j++)
            wt[i]+=bt[j];
    }
 
    printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time");
 
    //calculating turnaround time
    for(i=0;i<n;i++)
    {
        tat[i]=bt[i]+wt[i];
        avwt+=wt[i];
        avtat+=tat[i];
        printf("\nP[%d]\t\t%d\t\t%d\t\t%d",i+1,bt[i],wt[i],tat[i]);
    }
 
    avwt/=i;
    avtat/=i;
    printf("\n\nAverage Waiting Time is:%d",avwt);
    printf("\nAverage Turnaround Time is:%d",avtat);
 
    return 0;
}
----
SJF(Preemptive) Algorithm:-

Program:-

#include<iostream>
#include<algorithm>
using namespace std;

struct node{
    char pname;
    int btime;
    int atime;
    int restime=0;
    int ctime=0;
    int wtime=0;
}a[1000],b[1000],c[1000];

void insert(int n){
    int i;
    for(i=0;i<n;i++){
        cin>>a[i].pname;
        cin>>a[i].atime;
        cin>>a[i].btime;
        a[i].wtime=-a[i].atime+1;
    }
}

bool btimeSort(node a,node b){
    return a.btime < b.btime; 
}
bool btimeOppSort(node a,node b){
    if(a.btime!=b.btime)
        return a.btime > b.btime; 
    return a.atime < b.atime;
}
bool atimeSort(node a,node b){
    return a.atime < b.atime; 
}

int k=0,f=0,r=0;
void disp(int nop,int qt){
    int n=nop,q;
    sort(a,a+n,atimeSort);
    int ttime=0,i;
    int j,tArray[n];
    int alltime=0;
    bool moveLast=false;
    for(i=0;i<n;i++){
        alltime+=a[i].btime;
  //      cout<<"start is "<<a[i].pname<<" to "<<ttime<<"\n";
    }
    alltime+=a[0].atime;
    for(i=0;ttime<=alltime;){
        j=i;
        while(a[j].atime<=ttime&&j!=n){
     //       cout<<"less than atime is "<<a[j].pname<<" to "<<ttime<<"\n";
            b[r]=a[j];
            j++;
            r++;
        }
        if(r==f){
            c[k].pname='i';
            c[k].btime=a[j].atime-ttime;
            c[k].atime=ttime;
            ttime+=c[k].btime;
            k++;
            continue;
        }
        i=j;
        if(moveLast==true){
     //       cout<<"moving "<<b[f].pname<<" to "<<r<<"\n";
             sort(b+f,b+r,btimeSort);    
            // b[r]=b[f];
            // f++;
            // r++;
        }

        j=f;
        if(b[j].btime>qt){
            c[k]=b[j];
            c[k].btime=qt;
            k++;
            b[j].btime=b[j].btime-qt;
            ttime+=qt;  
            moveLast=true;
            for(q=0;q<n;q++){
                if(b[j].pname!=a[q].pname){
                    a[q].wtime+=qt;
                }
            }
        }
        else{
            c[k]=b[j];
            k++;
            f++;
            ttime+=b[j].btime;  
            moveLast=false;
            for(q=0;q<n;q++){
                if(b[j].pname!=a[q].pname){
                    a[q].wtime+=b[j].btime;
                }
            }
    //           cout<<"called for "<<b[j].pname<<" "<<b[j].btime<<"\n";
        }
        if(f==r&&i>=n)
        break;
    }
    tArray[i]=ttime;
    ttime+=a[i].btime;
    for(i=0;i<k-1;i++){
        if(c[i].pname==c[i+1].pname){
            c[i].btime+=c[i+1].btime;
            for(j=i+1;j<k-1;j++)
                c[j]=c[j+1];
            k--;
            i--;
        }
    }
    
    int rtime=0;
    for(j=0;j<n;j++){
        rtime=0;
        for(i=0;i<k;i++){
            if(c[i].pname==a[j].pname){
                a[j].restime=rtime;
                break;
            }
            rtime+=c[i].btime;
        }
    }

    float averageWaitingTime=0;
    float averageResponseTime=0;
    float averageTAT=0;
    
    cout<<"\nGantt Chart\n";
    rtime=0;
    for (i=0; i<k; i++){
        if(i!=k)
            cout<<"|  "<<'P'<< c[i].pname << "   "; 
        rtime+=c[i].btime;
        for(j=0;j<n;j++){
            if(a[j].pname==c[i].pname)
                a[j].ctime=rtime;
        } 
    }
    cout<<"\n";
    rtime=0;
    for (i=0; i<k+1; i++){
        cout << rtime << "\t";
        tArray[i]=rtime;
        rtime+=c[i].btime; 
    }

    cout<<"\n";
    cout<<"\n";
    cout<<"P.Name  Arrival\tBurst\tCT\tTAT\tWT\tRT\n";
    for (i=0; i<nop&&a[i].pname!='i'; i++){
        if(a[i].pname=='\0')
            break;
        cout <<'P'<< a[i].pname << "\t"; 
        cout << a[i].atime << "\t";
        cout << a[i].btime << "\t";
        cout << a[i].ctime << "\t"; 
        cout << a[i].wtime+a[i].ctime-rtime+a[i].btime << "\t"; 
        averageTAT+=a[i].wtime+a[i].ctime-rtime+a[i].btime;
        cout << a[i].wtime+a[i].ctime-rtime << "\t"; 
        averageWaitingTime+=a[i].wtime+a[i].ctime-rtime;
        cout << a[i].restime-a[i].atime << "\t";  
        averageResponseTime+=a[i].restime-a[i].atime;
        cout <<"\n"; 
    }

    cout<<"Average Response time: "<<(float)averageResponseTime/(float)n<<endl;
    cout<<"Average Waiting time: "<<(float)averageWaitingTime/(float)n<<endl;
    cout<<"Average TA time: "<<(float)averageTAT/(float)n<<endl;

}

int main(){
    int np,choice,i,qt;
    cout<<"<----------Program for SJF(Preemptive) Algorithm---------->\n\n";
    cout<<"Enter number of processes:-\n";
    cin>>np;
    cout<<"Enter process, ArrivalTime, BurstTime:-\n";
    insert(np);
    disp(np,1);
    return 0;
}
----
SJF (preemptive):-
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

typedef struct proccess
{
	int at,bt,ct,ta,wt,btt;
	string pro_id;

		/*
	artime = Arrival time,
	bt = Burst time,
	ct = Completion time,
	ta = Turn around time,
	wt = Waiting time
	*/

}Schedule;

bool compare(Schedule a,Schedule b)
{
	return a.at<b.at;

	/* This Schedule will always return TRUE
	if above condition comes*/
}
bool compare2(Schedule a,Schedule b)
{
	return a.bt<b.bt;

	/* This Schedule will always return TRUE
	if above condition comes*/
}

int main()
{
	Schedule pro[10];
	//An array of Processes
	int n,i,j,pcom;
	//n = number of processes, i= iteration variable

	cout<<"Enter the number of Process::";
	cin>>n;

	cout<<"Enter the Process id arrival time burst time :::";

	for(i=0;i<n;i++)
	{
		cin>>pro[i].pro_id;
		cin>>pro[i].at;
		cin>>pro[i].bt;
		pro[i].btt=pro[i].bt;
	}

	sort(pro,pro+n,compare);

	/*sort is a predefined funcion  defined in algorithm.h header file,
	it will sort the processes according to their arrival time*/

	i=0;
	pcom=0;
	while(pcom<n)
	{
		for(j=0;j<n;j++)
		{
			if(pro[j].at>i)
			break;
		}

		sort(pro,pro+j,compare2);

		/*sort is a predefined funcion  defined in algorithm.h header file,
	it will sort the processes according to their burst time*/

		if(j>0)
		{

			for(j=0;j<n;j++)
			{
				if(pro[j].bt!=0)
				break;
			}
			if(pro[j].at>i)

			{
				i=pro[j].at;

			}
			pro[j].ct=i+1;
			pro[j].bt--;
		}
		i++;
		pcom=0;
		for(j=0;j<n;j++)
		{
			if(pro[j].bt==0)
			pcom++;
		}
	}

	cout<<"ProID\tAtime\tBtime\tCtime\tTtime\tWtime\n";

	for(i=0;i<n;i++)
	{
		pro[i].ta=pro[i].ct-pro[i].at;
		pro[i].wt=pro[i].ta-pro[i].btt;

		/*Printing the Process id, arrival time, burst time,
		completion time, turn around time, waiting time*/

		cout<<pro[i].pro_id<<"\t"<<pro[i].at<<"\t"<<pro[i].btt<<"\t"<<pro[i].ct<<"\t"<<pro[i].ta<<"\t"<<pro[i].wt;
		cout<<endl;
	}
	return 0;
}
----
SJF(Non-Preemptive) Algorithm:-

Program:-

#include<iostream>
#include<algorithm>
using namespace std;

struct node{
    char pname[50];
    int btime;
    int atime;
}a[50];

void insert(int n){
    int i;
    for(i=0;i<n;i++){
        cin>>a[i].pname;
        cin>>a[i].atime;
        cin>>a[i].btime;
    }
}

bool btimeSort(node a,node b){
    return a.btime < b.btime; 
}

bool atimeSort(node a,node b){
    return a.atime < b.atime; 
}

void disp(int n){
    sort(a,a+n,btimeSort);
    sort(a,a+n,atimeSort);
    int ttime=0,i;
    int j,tArray[n];
    for(i=0;i<n;i++){
        j=i;
        while(a[j].atime<=ttime&&j!=n){
            j++;
        }
        sort(a+i,a+j,btimeSort);
        tArray[i]=ttime;
        ttime+=a[i].btime;
    }
    tArray[i] = ttime;

    float averageWaitingTime=0;
    float averageResponseTime=0;
    float averageTAT=0;
    cout<<"\n";
    cout<<"P.Name  AT\tBT\tCT\tTAT\tWT\tRT\n";
    for (i=0; i<n; i++){
        cout << a[i].pname << "\t"; 
        cout << a[i].atime << "\t";
        cout << a[i].btime << "\t";
        cout << tArray[i+1] << "\t"; 
        cout << tArray[i]-a[i].atime+a[i].btime << "\t"; 
        averageTAT+=tArray[i]-a[i].atime+a[i].btime;
        cout << tArray[i]-a[i].atime << "\t"; 
        averageWaitingTime+=tArray[i]-a[i].atime;
        cout << tArray[i]-a[i].atime << "\t";  
        averageResponseTime+=tArray[i]-a[i].atime;
        cout <<"\n"; 
    }
    cout<<"\n";
    cout<<"\nGantt Chart\n";
    for (i=0; i<n; i++){
        cout <<"|   "<< a[i].pname << "   "; 
    }
    cout<<"\n";
    for (i=0; i<n+1; i++){
        cout << tArray[i] << "\t"; 
    }
    cout<<"\n";
    cout<<"Average Response time: "<<(float)averageResponseTime/(float)n<<endl;
    cout<<"Average Waiting time: "<<(float)averageWaitingTime/(float)n<<endl;
    cout<<"Average TA time: "<<(float)averageTAT/(float)n<<endl;
}

int main(){
    int nop,choice,i;
    cout<<"<----------Program for SJF(Non-Preemptive) Algorithm---------->\n\n";
    cout<<"Enter number of processes:\n";
    cin>>nop;
    insert(nop);
    disp(nop);
    return 0;
}
----
Priority (Preemptive) Algorithm:-
#include<iostream>

 using namespace std;
int main()
{
    int a[10],b[10],x[10];
    int waiting[10],turnaround[10],completion[10],p[10];
    int i,j,smallest,count=0,time,n;
    double avg=0,tt=0,end;

   cout<<"\nEnter the number of Processes: ";
    cin>>n;
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter arrival time of process: ";
      cin>>a[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter burst time of process: ";
      cin>>b[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter priority of process: ";
      cin>>p[i];
    }
    for(i=0; i<n; i++)
        x[i]=b[i];

    p[9]=-1;
    for(time=0; count!=n; time++)
    {
        smallest=9;
        for(i=0; i<n; i++)
        {
            if(a[i]<=time && p[i]>p[smallest] && b[i]>0 )
                smallest=i;
        }
        b[smallest]--;

        if(b[smallest]==0)
        {
            count++;
            end=time+1;
            completion[smallest] = end;
            waiting[smallest] = end - a[smallest] - x[smallest];
            turnaround[smallest] = end - a[smallest];
        }
    }
     cout<<"Process"<<"\t"<< "burst-time"<<"\t"<<"arrival-time" <<"\t"<<"waiting-time" <<"\t"<<"turnaround-time"<< "\t"<<"completion-time"<<"\t"<<"Priority"<<endl;
    for(i=0; i<n; i++)
    {
         cout<<"p"<<i+1<<"\t\t"<<x[i]<<"\t\t"<<a[i]<<"\t\t"<<waiting[i]<<"\t\t"<<turnaround[i]<<"\t\t"<<completion[i]<<"\t\t"<<p[i]<<endl;
        avg = avg + waiting[i];
        tt = tt + turnaround[i];
    }
   cout<<"\n\nAverage waiting time ="<<avg/n;
    cout<<"  Average Turnaround time ="<<tt/n<<endl;
}

----
Priority (Non-Preemptive) Algorithm:-

Program:-

#include<iostream>

using namespace std;
int main()
{
    int a[10],b[10],x[10],pr[10]={0};
    int waiting[10],turnaround[10],completion[10];
    int i,j,smallest,count=0,time,n;
    double avg=0,tt=0,end;
    cout<<"<----------Program for Priority(Non-Preemptive) Algorithm---------->\n\n";
   cout<<"\nEnter the number of Processes:";
    cin>>n;
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter Arrival time of P["<<i<<"]:";
      cin>>a[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter Burst time of P["<<i<<"]:";
      cin>>b[i];
    }
    for(i=0;i<n;i++)
    {
      cout<<"\nEnter Priority of P["<<i<<"]:";
      cin>>pr[i];
    }
    for(i=0;i<n;i++)
        x[i]=b[i];

    pr[9]=-1;
    for(time=0;count!=n;time++)
    {
        smallest=9;
        for(i=0;i<n;i++)
        {
            if(a[i]<=time && pr[i]>pr[smallest] && b[i]>0 )
                smallest=i;
        }
        time+=b[smallest]-1;
        b[smallest]=-1;
        count++;
        end=time+1;
        completion[smallest] = end;
        waiting[smallest] = end - a[smallest] - x[smallest];
        turnaround[smallest] = end - a[smallest];
    }
    cout<<"Process"<<"\t"<< "Burst time"<<"\t"<<"Arrival time" <<"\t"<<"Waiting time" <<"\t"<<"Turnaround time"<< "\t"<<"Completion time"<<"\t\t"<<"Priority"<<endl;
    for(i=0;i<n;i++)
    {
        cout<<"p"<<i+1<<"\t\t"<<x[i]<<"\t\t"<<a[i]<<"\t\t"<<waiting[i]<<"\t\t"<<turnaround[i]<<"\t\t"<<completion[i]<<"\t\t"<<pr[i]<<endl;
        avg = avg + waiting[i];
        tt = tt + turnaround[i];
    }
    cout<<"\n\nAverage waiting time:"<<avg/n;
    cout<<"\nAverage Turnaround time:"<<tt/n<<endl;
}
----
Round Robin Algorithm:-

Program:-


#include <iostream>

/*at = Arrival time,
bt = Burst time,
time_quantum= Quantum time
tat = Turn around time,
wt = Waiting time*/

using namespace std;

int main(){
	int i,n,time,remain,temps=0,time_quantum;

	int wt=0,tat=0;
	cout<<"<----------Program for Round Robin Algorithm---------->\n\n";
	cout<<"Enter the Total number of processes:"<<endl;
	cin>>n;

	remain=n;
	// assigning the number of process to remain variable

	int at[n];
	int bt[n];
	int rt[n];


	cout<<"Enter the Arrival time, Burst time:\n"<<endl;
	for(i=0;i<n;i++)
	{
	  cout<<"Arrival time for P["<<i+1<<"]"<<endl;
		cin>>at[i];
		cout<<"Burst time for P["<<i+1<<"]"<<endl;
		cin>>bt[i];
		rt[i]=bt[i];
	}

	cout<<"Enter the value of time QUANTUM:"<<endl;
	cin>>time_quantum;

	cout<<"\n\nProcess\tTurnaround Time\tWaiting Time\n\n";
	for(time=0,i=0;remain!=0;)
	{
		if(rt[i]<=time_quantum && rt[i]>0)
		{
			time += rt[i];
		
			rt[i]=0;
			temps=1;
		}

		else if(rt[i]>0)
		{
			rt[i] -= time_quantum;
		
			time += time_quantum;
		
		}

		if(rt[i]==0 && temps==1)
		{
			remain--;
			//Desplaying the result of wating, turn around time:
			printf("P[%d]\t\t %d\t %d\n",i+1,time-at[i],time-at[i]-bt[i]);
			cout<<endl;

			wt += time-at[i]-bt[i];
			tat += time-at[i];
			temps=0;
		}

		if(i == n-1)
			i=0;
		else if(at[i+1] <= time)
			i++;
		else
			i=0;
	}

	cout<<"Average waiting time "<<wt*1.0/n<<endl;
	cout<<"Average turn around time "<<tat*1.0/n<<endl;;

	return 0;
}
----
MENU DRIVEN:-
#include<iostream>
#include <algorithm>
#include <cstring>

using namespace std;


            typedef struct proccess					//Function For Preemptive SJF Algorithm
            {
                float at,bt,ct,ta,wt,btt;
                string pro_id;

            }Schedule;

            bool compare(Schedule a,Schedule b)
            {
                return a.at<b.at;
            }

            bool compare2(Schedule a,Schedule b)
            {
                return a.bt<b.bt;
            }



class scheduling				//Class Scheduling intilialized
{
public:
        void FCFS()					//Function For FCFS Algorithm
        {
            cout<<"\n For FCFS Algorithm\n";
            int n,bt[20],wt[20],tat[20],i,j;
            float avwt=0,avtat=0;
            cout<<"Enter total number of processes:";
            cin>>n;

            cout<<"\nEnter Process Burst Time\n";
            for(i=0;i<n;i++)
            {
                cout<<"P["<<i+1<<"]:";
                cin>>bt[i];
            }

            wt[0]=0;    //waiting time for first process is 0

            //calculating waiting time
            for(i=1;i<n;i++)
            {
                wt[i]=0;
                for(j=0;j<i;j++)
                    wt[i]+=bt[j];
            }

            cout<<"\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time";

            //calculating turnaround time
            for(i=0;i<n;i++)
            {
                tat[i]=bt[i]+wt[i];
                avwt+=wt[i];
                avtat+=tat[i];
                cout<<"\nP["<<i+1<<"]"<<"\t\t"<<bt[i]<<"\t\t"<<wt[i]<<"\t\t"<<tat[i];
            }

            avwt/=i;
            avtat/=i;
            cout<<"\nFor FCFS Algorithm";
            cout<<"\nAverage Waiting Time:"<<avwt;
            cout<<"\nAverage Turnaround Time:"<<avtat;
            cout<<"\n";
        }


        void Non_pre_SJF()				//Function For Non-Preemptive SJF Algorithm
        {
            cout<<"\nFor SJF Algorithm\n";
            int n,bt[20],wt[20],tat[20],i,j;
            float avwt=0,avtat=0;
            cout<<"Enter total number of processes:";
            cin>>n;

            cout<<"\nEnter Process Burst Time\n";
            for(i=0;i<n;i++)
            {
                cout<<"P["<<i+1<<"]:";
                cin>>bt[i];
            }

            for(i=0;i<n;i++)
              {
                 for(j=i+1;j<n;j++)
                  {
                        if(bt[i]>bt[j])
                        {

                              int temp=bt[i];
                              bt[i]=bt[j];
                              bt[j]=temp;
                        }
                  }
              }

            wt[0]=0;    //waiting time for first process is 0

            //calculating waiting time
            for(i=1;i<n;i++)
            {
                wt[i]=0;
                for(j=0;j<i;j++)
                    wt[i]+=bt[j];
            }

            cout<<"\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time";

            //calculating turnaround time
            for(i=0;i<n;i++)
            {
                tat[i]=bt[i]+wt[i];
                avwt+=wt[i];
                avtat+=tat[i];
                cout<<"\nP["<<i+1<<"]"<<"\t\t"<<bt[i]<<"\t\t"<<wt[i]<<"\t\t"<<tat[i];
            }

            avwt/=i;
            avtat/=i;
            cout<<"\nFor SJF Algorithm";
            cout<<"\nAverage Waiting Time:"<<avwt;
            cout<<"\nAverage Turnaround Time:"<<avtat;
            cout<<"\n";
        }


        void pre_SJF()										//Function For Preemptive SJF Algorithm
        {
             cout<<"\nFor SJF(Preemptive) Algorithm\n";
            Schedule pro[10];						//An array of Processes
            int n,i,j,pcom;								//n = number of processes, i= iteration variable
            

            cout<<"Enter the number of Process::";
            cin>>n;

            cout<<"Enter the Process arrival time & burst time :\n";

            for(i=0;i<n;i++)
            {
                cin>>pro[i].pro_id;
                cin>>pro[i].at;
                cin>>pro[i].bt;
                pro[i].btt=pro[i].bt;
            }

            sort(pro,pro+n,compare);


            i=0;
            pcom=0;
            while(pcom<n)
            {
                for(j=0;j<n;j++)
                {
                    if(pro[j].at>i)
                    break;
                }

                sort(pro,pro+j,compare2);


                if(j>0)
                {

                    for(j=0;j<n;j++)
                    {
                        if(pro[j].bt!=0)
                        break;
                    }
                    if(pro[j].at>i)

                    {
                        i=pro[j].at;

                    }
                    pro[j].ct=i+1;
                    pro[j].bt--;
                }
                i++;
                pcom=0;
                for(j=0;j<n;j++)
                {
                    if(pro[j].bt==0)
                    pcom++;
                }
            }

            cout<<"\n\nProID\tAtime\tBtime\tCtime\tTtime\tWtime\n";
            float twt=0,ttat=0;

            for(i=0;i<n;i++)
            {
                pro[i].ta=pro[i].ct-pro[i].at;
                pro[i].wt=pro[i].ta-pro[i].btt;


                cout<<pro[i].pro_id<<"\t"<<pro[i].at<<"\t"<<pro[i].btt<<"\t"<<pro[i].ct<<"\t"<<pro[i].ta<<"\t"<<pro[i].wt;
                twt=twt+pro[i].wt;
                ttat=ttat+pro[i].ta;
                cout<<endl;
            }

            cout<<"\nFor SJF(Preemptive) Algorithm\nAvg. Waiting Time:"<<twt/n<<"\nAvg. Turnaround Time:"<<ttat/n<<"\n";
        }

        void Round_Robin()							//Function For Round Robin Algorithm
        {
             cout<<"\nFor Round Robin Algorithm\n";
            int i,n,time,remain,temps=0,time_quantum;

                int wt=0,tat=0;

                cout<<"\nEnter the Total Number of Process:";
                cin>>n;

                remain=n;


                int at[n];
                int bt[n];
                int rt[n];
                for(i=0;i<n;i++)
                {
                    cout<<"\n\n"<<"Arrival time for Process "<<i+1<<":";
                    cin>>at[i];
                    cout<<"Burst time for process "<<i+1<<":";
                    cin>>bt[i];
                    rt[i]=bt[i];
                }

                cout<<"\nEnter QUANTUM Time"<<":";
                cin>>time_quantum;

                cout<<"\n\nProcess\t \tBurst Time\t \tTurnaround Time\t \tWaiting Time\n\n";
                for(time=0,i=0;remain!=0;)
                {
                    if(rt[i]<=time_quantum && rt[i]>0)
                    {
                        time += rt[i];

                        rt[i]=0;
                        temps=1;
                    }

                    else if(rt[i]>0)
                    {
                        rt[i] -= time_quantum;

                        time += time_quantum;

                    }

                    if(rt[i]==0 && temps==1)
                    {
                        remain--;

                        printf("Process %d \t \t%d\t \t%d\t \t\t%d\n",i+1,bt[i],time-at[i],time-at[i]-bt[i]);
                        cout<<endl;

                        wt += time-at[i]-bt[i];
                        tat += time-at[i];
                        temps=0;
                    }



                    if(i == n-1)
                        i=0;
                    else if(at[i+1] <= time)
                        i++;
                    else
                        i=0;
                }

                cout<<"\nFor Round Robin Algorithm";
                cout<<"\nTotal Waiting Time:"<<wt;
                cout<<"\nAverage Waiting Time "<<wt*1.0/n<<endl;
                cout<<"\nTotal Turn Around Time:"<<tat;
                cout<<"\nAverage Turn Around Time "<<tat*1.0/n<<endl;

        }//end of RR


        void Priority()								//Function For Priority Algorithm
        {
             cout<<"\nPriority\n";
                int a[10],b[10],x[10];
                int waiting[10],turnaround[10],completion[10],p[10];
                int i,j,smallest,count=0,time,n;
                double avg=0,tt=0,end;

                cout<<"\nEnter the number of Processes: ";
                cin>>n;
                for(i=0;i<n;i++)
                {
                  cout<<"\nEnter arrival time of process["<<i+1<<"]:";
                  cin>>a[i];
                }
                for(i=0;i<n;i++)
                {
                  cout<<"\nEnter burst time of process["<<i+1<<"]:";
                  cin>>b[i];
                }
                for(i=0;i<n;i++)
                {
                  cout<<"\nEnter priority of process["<<i+1<<"]:";
                  cin>>p[i];
                }
                for(i=0; i<n; i++)
                    x[i]=b[i];

                p[9]=-1;
                for(time=0; count!=n; time++)
                {
                    smallest=9;
                    for(i=0; i<n; i++)
                    {
                        if(a[i]<=time && p[i]>p[smallest] && b[i]>0 )
                            smallest=i;
                    }
                    b[smallest]--;

                    if(b[smallest]==0)
                    {
                        count++;
                        end=time+1;
                        completion[smallest] = end;
                        waiting[smallest] = end - a[smallest] - x[smallest];
                        turnaround[smallest] = end - a[smallest];
                    }
                }
                cout<<"\nPriority Scheduling";
                cout<<"\nProcess"<<"\t"<< " Burst-Time"<<"\t"<<" Arrival Time" <<"\t"<<" Waiting Time" <<"\t"<<" Turnaround Time"<< "\t"<<"Completion Time  "<<"\t"<<"  Priority"<<endl;
                for(i=0; i<n; i++)
                {
                     cout<<"p"<<i+1<<"\t\t"<<x[i]<<"\t\t"<<a[i]<<"\t\t"<<waiting[i]<<"\t\t"<<turnaround[i]<<"\t\t\t"<<completion[i]<<"\t\t  "<<p[i]<<endl;
                     avg = avg + waiting[i];
                     tt = tt + turnaround[i];
                }
               
                cout<<"\n\nAverage waiting time:"<<avg/n;
                cout<<"\nAverage Turnaround time:"<<tt/n<<endl;
       

        }

};

int main()
{
    int ch;
    scheduling s;

    do
    {
        cout<<"\n<----------Process Scheduling Algorithm---------->";
        cout<<"\n1.FCFS\n2.SJF(Non-Preemptive)\n3.SJF(Preemptive)\n4.Priority(Non-Preemptive)\n5.Round Robin\n6.Exit\n\nEnter Your Choice:";
        cin>>ch;

        switch(ch)
        {
            case 1:         s.FCFS();
                            break;

            case 2:         s.Non_pre_SJF();
                            break;

            case 3:         s.pre_SJF();
                            break;

            case 4:         s.Priority();
                            break;

            case 5:         s.Round_Robin();
                            break;

            case 6:       
                            exit(0);
        }
    }while(ch!=6);

    return 0;
}
----
// Banker's Algorithm
#include <stdio.h>
#include <stdlib.h>

void final_output(int k[][10], int n, int p)
{
	int i, j;
	for (i = 0; i < n; i++)
	{
		printf("\n");
		for (j = 0; j < p; j++)
		{
			printf("%d\t", k[i][j]);
		}
	}
}

void Banker(int A[][10], int N[][10],
	int M[10][10], int W[1][10], int *n, int *m)
{
	int i, j;
	printf("\n Enter total number of processes : ");
	scanf("%d", n);
	printf("\n Enter total number of resources : ");
	scanf("%d", m);
	for (i = 0; i<*n; i++)
	{
		printf("\n Process %d\n", i + 1);
		for (j = 0; j<*m; j++)
		{
			printf(" Allocation for resource %d : ", j + 1);
			scanf("%d", &A[i][j]);
			printf(" Maximum for resource %d : ", j + 1);
			scanf("%d", &M[i][j]);
		}
	}

	printf("\n Available resources : \n");
	for (i = 0; i<*m; i++)
	{
		printf(" Resource %d : ", i + 1);
		scanf("%d", &W[0][i]);
	}

	for (i = 0; i<*n; i++)
		for (j = 0; j<*m; j++)
			N[i][j] = M[i][j] - A[i][j];
	printf("\n -----Allocation Matrix-----");
	final_output(A, *n, *m);
	printf("\n -----Maximum Requirement Matrix-----");
	final_output(M, *n, *m);
	printf("\n -----Need Matrix-----");
	final_output(N, *n, *m);
}

int safety(int A[][10], int N[][10],
	int B[1][10], int n, int m, int a[])
{
	int i, j, k, x = 0, f1 = 0, f2 = 0;
	int F[10], W[1][10];
	for (i = 0; i < n; i++)
		F[i] = 0;
	for (i = 0; i < m; i++)
		W[0][i] = B[0][i];
	for (k = 0; k < n; k++)
	{
		for (i = 0; i < n; i++)
		{
			if (F[i] == 0)
			{
				f2 = 0;
				for (j = 0; j < m; j++)
				{
					if (N[i][j] > W[0][j])
						f2 = 1;
				}

				if (f2 == 0 && F[i] == 0)
				{
					for (j = 0; j < m; j++)
						W[0][j] += A[i][j];
					F[i] = 1;
					f1++;
					a[x++] = i;
				}
			}
		}

		if (f1 == n)
			return 1;
	}

	return 0;
}

void request(int A[10][10], int N[10][10], int B[10][10], int pid, int K)
{
	int rmat[1][10];
	int i;
	printf("\n Enter additional request : \n");
	for (i = 0; i < K; i++)
	{
		printf(" Request for resource %d : ", i + 1);
		scanf("%d", &rmat[0][i]);
	}

	for (i = 0; i < K; i++)
		if (rmat[0][i] > N[pid][i])
		{
			printf("\n ***Error encountered***\n");
			exit(0);
		}

	for (i = 0; i < K; i++)
		if (rmat[0][i] > B[0][i])
		{
			printf("\n ***Resources unavailable**\n");
			exit(0);
		}

	for (i = 0; i < K; i++)
	{
		B[0][i] -= rmat[0][i];
		A[pid][i] += rmat[0][i];
		N[pid][i] -= rmat[0][i];
	}
}

int banker(int A[][10], int N[][10],
	int W[1][10], int n, int m)
{
	int j, i, a[10];
	j = safety(A, N, W, n, m, a);
	if (j != 0)
	{
		printf("\n\n");
		printf("\n A safety sequence has been "
			"detected.\n");
		for (i = 0; i < n; i++)
			printf(" P%d ", a[i]);
		printf("\n");
		return 1;
	}
	else
	{
		printf("\n Deadlock has occured.\n");
		return 0;
	}
}

int main()
{
	int All[10][10], Max[10][10], Need[10][10], W[1][10];
	int n, m, pid, c, r;
	printf("\n -----BANKER'S ALGORITHM-----\n");
	Banker(All, Need, Max, W, &n, &m);
	r = banker(All, Need, W, n, m);
	if (r != 0)
	{
		printf("\n Do you want to continue?");
		scanf("%d", &c);
		if (c == 1)
		{
			printf("\n Enter process number : ");
			scanf("%d", &pid);
			request(All, Need, W, pid - 1, m);
			r = banker(All, Need, W, n, m);
			if (r == 0)
			{
				exit(0);
			}
		}
	}
	else
		exit(0);
	return 0;
}
----
//Banker Algorithm1
// Banker's Algorithm
#include <iostream>
using namespace std;

int main()
{
	// P0, P1, P2, P3, P4 are the Process names here

int n, m, i, j, k;
n = 5; // Number of processes
m = 3; // Number of resources
int alloc[5][3] = { { 0, 1, 0 }, // P0 // Allocation Matrix
					{ 2, 0, 0 }, // P1
					{ 3, 0, 2 }, // P2
					{ 2, 1, 1 }, // P3
					{ 0, 0, 2 } }; // P4

int max[5][3] = { { 7, 5, 3 }, // P0 // MAX Matrix
				{ 3, 2, 2 }, // P1
				{ 9, 0, 2 }, // P2
				{ 2, 2, 2 }, // P3
				{ 4, 3, 3 } }; // P4

int avail[3] = { 3, 3, 2 }; // Available Resources

int f[n], ans[n], ind = 0;
for (k = 0; k < n; k++) {
	f[k] = 0;
}
int need[n][m];
for (i = 0; i < n; i++) {
	for (j = 0; j < m; j++)
	need[i][j] = max[i][j] - alloc[i][j];
}
int y = 0;
for (k = 0; k < 5; k++) {
	for (i = 0; i < n; i++) {
	if (f[i] == 0) {

		int flag = 0;
		for (j = 0; j < m; j++) {
		if (need[i][j] > avail[j]){
			flag = 1;
			break;
		}
		}

		if (flag == 0) {
		ans[ind++] = i;
		for (y = 0; y < m; y++)
			avail[y] += alloc[i][y];
		f[i] = 1;
		}
	}
	}
}

cout << "Following is the SAFE Sequence" << endl;
for (i = 0; i < n - 1; i++)
	cout << " P" << ans[i] << " ->";
cout << " P" << ans[n - 1] <<endl;

	return (0);
}
----
Barber Program:-
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>

// The maximum number of customer threads.
#define MAX_CUSTOMERS 25

// Function prototypes…
void *customer(void *num);
void *barber(void*);

void randwait(int secs);

// Define the semaphores.

// waitingRoom Limits the # of customers allowed
// to enter the waiting room at one time.
sem_t waitingRoom;

// barberChair ensures mutually exclusive access to
// the barber chair.
sem_t barberChair;

// barber_sleep is used to allow the barber to sleep
// until a customer arrives.
sem_t barber_sleep;

// seatBelt is used to make the customer to wait until
// the barber is done cutting his/her hair.
sem_t seatBelt;

// Flag to stop the barber thread when all customers
// have been serviced.
int allDone = 0;

int main(int argc, char *argv[])
{
	pthread_t btid;
	pthread_t tid[MAX_CUSTOMERS];
	long RandSeed;
	int i, numCustomers, numChairs;
	int Number[MAX_CUSTOMERS];

	printf("Enter the number of Custmors : ");
	scanf("%d", &numCustomers);
	printf("Enter the number of Charis : ");
	scanf("%d", &numChairs);

	// Make sure the number of threads is less than the number of
	// customers we can support.
	if (numCustomers > MAX_CUSTOMERS)
	{
		printf("The maximum number of Customers is %d.\n", MAX_CUSTOMERS);
		exit(-1);
	}

	// Initialize the numbers array.
	for (i = 0; i < MAX_CUSTOMERS; i++)
	{
		Number[i] = i;
	}

	// Initialize the semaphores with initial values…
	sem_init(&waitingRoom, 0, numChairs);
	sem_init(&barberChair, 0, 1);
	sem_init(&barber_sleep, 0, 0);
	sem_init(&seatBelt, 0, 0);

	// Create the barber.
	pthread_create(&btid, NULL, barber, NULL);

	// Create the customers.
	for (i = 0; i < numCustomers; i++)
	{
		pthread_create(&tid[i], NULL, customer, (void*) &Number[i]);
		sleep(1);
	}

	// Join each of the threads to wait for them to finish.
	for (i = 0; i < numCustomers; i++)
	{
		pthread_join(tid[i], NULL);
		sleep(1);
	}

	// When all of the customers are finished, kill the
	// barber thread.
	allDone = 1;
	sem_post(&barber_sleep);	// Wake the barber so he will exit.
	pthread_join(btid, NULL);
}

void *customer(void *number)
{
	int num = *(int*) number;

	// Leave for the shop and take some random amount of
	// time to arrive.
	printf("Customer %d leaving for barber shop.\n", num);
	randwait(2);
	printf("Customer %d arrived at barber shop.\n", num);

	// Wait for space to open up in the waiting room…
	sem_wait(&waitingRoom);
	printf("Customer %d entering waiting room.\n", num);

	// Wait for the barber chair to become free.
	sem_wait(&barberChair);

	// The chair is free so give up your spot in the
	// waiting room.
	sem_post(&waitingRoom);

	// Wake up the barber…
	printf("Customer %d waking the barber.\n", num);
	sem_post(&barber_sleep);

	// Wait for the barber to finish cutting your hair.
	sem_wait(&seatBelt);

	// Give up the chair.
	sem_post(&barberChair);
	printf("Customer %d leaving barber shop.\n", num);
}

void *barber(void *junk)
{
	// While there are still customers to be serviced…
	// Our barber is omnicient and can tell if there are
	// customers still on the way to his shop.
	while (!allDone)
	{

		// Sleep until someone arrives and wakes you..
		printf("The barber is sleeping\n");
		sem_wait(&barber_sleep);

		// Skip this stuff at the end…
		if (!allDone)
		{

			// Take a random amount of time to cut the
			// customer’s hair.
			printf("The barber is cutting hair\n");
			randwait(2);
			printf("The barber has finished cutting hair.\n");

			// Release the customer when done cutting…
			sem_post(&seatBelt);
		}
		else
		{
			printf("The barber is going home for the day.\n");
		}
	}
}

void randwait(int secs)
{
	int len;

	// Generate a random number…
	len = (int)((1 *secs) + 1);
	sleep(len);
}
----
page replacement algorithm
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void FIFO(){
	int p,f,n,i,pf=0,ph=0,j;
	char* str,*frame;
	printf("Enter the frame size : ");
	scanf("%d",&f);
	printf("Enter the string size : ");
	scanf("%d",&n);
	str=(char*)malloc(n*sizeof(char));
	frame=(char*)malloc(f*sizeof(char));
	for(i=0;i<f;i++) frame[i]=' ';
	printf("Enter the string : ");
	scanf("%s",str);
	p=0;
	for(i=0;i<f;i++) printf("%d",i+1);
	printf("\n\n");
	for(i=0;i<n;i++){
		if(strchr(frame,str[i])==NULL){
			pf++;
			frame[p]=str[i];
			p=(p+1)%f;
		}else{
			ph++;
		}
		for(j=0;j<f;j++){
			printf("%c",frame[j]);
		}
		printf("\n");
	}
	printf("Page Fault : %d",pf);
	printf("Page Hit : %d",ph);
}

char* substr(char* str,int index,int length){
	if(index>=strlen(str)||index+length>strlen(str)){
		return "";
	}
	char* chr,*ch;
	chr=(char*)malloc(strlen(str)*sizeof(char));
	strcpy(chr,str);
	chr=chr+index;
	ch=chr+length;
	*ch='\0';
	return chr;
}

void LRU(){
	int f,n,i,j,s,e,pf=0,ph=0;
	s=e=-1;
	char *frame,*string;
	printf("Enter the frame size : ");
	scanf("%d",&f);
	printf("Enter the string size : ");
	scanf("%d",&n);
	frame=(char*)malloc(f*sizeof(char));
	string=(char*)malloc(n*sizeof(char));
	for(i=0;i<f;i++) frame[i]=' ';
	printf("Enter the string : ");
	scanf("%s",string);
	for(i=0;i<n;i++){
		if(strchr(frame,string[i])==NULL){
			
			//frame=string[i]+substr(frame,1,f-1);
			strcpy(frame,strcat(substr(string,i,1),substr(frame,0,f-1)));
			pf++;
		}else{
			
			int x=(int)(strchr(frame,string[i])-frame);
			
			//frame=string[i] + substr(frame,0,x) + substr(frame,x+1,f-x-1);
			//*frame=string[i];
			
			/*frame[0]=string[i];
			frame=substr(frame,0,1);
			strcat(frame,substr(frame,0,x));
			strcat(frame,substr(frame,x+1,f-x-1));*/
			strcpy(frame,strcat(strcat(substr(frame,x,1),substr(frame,0,x)),substr(frame,x+1,f-1-x)));
			
			ph++;
		}
		printf("%s\n",frame);
	}
	printf("Page Fault : %d",pf);
	printf("Page Hit : %d",ph);
}

void OPT(){
	int f,n,i,max,j,pf=0,ph=0;
	char *frame,*string;
	printf("Enter the frame size : ");
	scanf("%d",&f);
	printf("Enter the string size : ");
	scanf("%d",&n);
	frame=(char*)malloc(f*sizeof(char));
	string=(char*)malloc(n*sizeof(char));
	for(i=0;i<f;i++) frame[i]=' ';
	printf("Enter the string : ");
	scanf("%s",string);
	for(i=0;i<n;i++){
		if(strchr(frame,string[i])==NULL){
			pf++;
			max=0;
			int p,q;
			for(j=0;j<f;j++){
				char* sub=strchr(string+i+1,frame[j]);
				p=(int)(strchr(string+i+1,frame[j])-string);
				if(sub==NULL){
					q=j;
					break;
				}else if(p>max){
					//printf("%d ",sub);
					max=p;
					q=j;
				}
			}
			//printf("\n");
			frame[q]=string[i];
		}else{
			ph++;
		}
		printf("%s\n",frame);
	}
	printf("Page Fault : %d",pf);
	printf("Page Hit : %d",ph);
}

void main(){
	char ch;
	printf("<----------Page Replacement Algorithms---------->\n");
	printf("Select Replacement Algorithm:-\n1.FIFO\n2.LRU\n3.OPTIMAL\n\nEnter Your Choice : ");
	scanf("%c",&ch);
	if(ch=='1'){
		FIFO();
	}else if(ch=='2'){
		LRU();
	}else if(ch=='3'){
		OPT();
	}else{
		printf("Invalid choice");
	}
}
----



