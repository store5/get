parity check
#include<stdio.h>
using namespace std;
int main() {
  int parity = 0, num;
  printf("<----------Parity Checker Code---------->\n\n");
  printf("Enter Binary Number:-");
  scanf("%d", & num);
  while (num) // loop will operate until number becomes 0..by right shifting again & again
  {
    if (num & 1) //....MAKE (num & 1)..&..extract 1 bit 
      parity = !parity;
    num = num >> 1; //after checking 1st bit...check the next bit to that bit which is already     
  }
  if (parity == 1) //1 is representing that parity is odd..//
    printf("Parity is odd");
  else
    printf("Parity is even"); //0 is representing that parity is even..//
  return 0;
}
----
hamming code
#include <cstdlib>
#include <iostream>
#include <math.h>
using namespace std;
int main(int argc, char** argv) {
    int data_bits[20],m,r = 0,parity;    //m = no. of data bits, r = no. of redundant bits
    
    cout<<"<----------Hamming Code---------->\n\n";
    cout<<"Enter the size of data bits: ";
    cin>>m;
    
    //finding no. of redundant bits
    while(pow (2,r) < m + r + 1){
        r++;
    }
    
    cout<<"Enter the data bit: ";
    for(int i = 1; i <= m; i++)
        cin>>data_bits[i];
    
    int hamming[m + r],j = 0,k = 1;    
    
    //finding positions of redundant bits.
    for(int i = 1; i <= m + r; i++){
        
        if( i == pow( 2, j )){
            hamming[i] = -1;    //-1 is initial value of redundant bits
            j++;
        }
        else{
            hamming[i] = data_bits[k];
            k++;
        }
    }
    
    k = 0;
    int x, min, max = 0;
    //finding parity bit
    for (int i = 1; i <= m + r; i = pow (2, k)){
      k++;
      parity = 0;
      j = i;
      x = i;
      min = 1;
      max = i;
       while ( j <= m + r){
          for (x = j; max >= min && x <= m + r; min++, x++){
              if (hamming[x] == 1)
                  parity = parity + 1;;
          }
          j = x + i;
          min = 1;
      }
      
      //checking for even parity
      if (parity % 2 == 0){ 
         hamming[i] = 0;
      }
      else{
        hamming[i] = 1;
      }
  }
    
    cout<<"\nHamming code is: ";
    for(int i = 1; i <= m + r; i++)
        cout<<hamming[i]<<" ";
    
    return 0;
}
----
cyclic redundancy
#include <iostream>
#include <math.h>
#include <cstring>

using namespace std;

char exor(char a, char b) // perform exor operation
{
  if (a == b)
    return '0';
  else
    return '1';
}

void crc(char data[], char key[]) {
  int datalen = strlen(data);
  int keylen = strlen(key);

  for (int i = 0; i < keylen - 1; i++) //appending n-1 zeroes to data
    data[datalen + i] = '0';
  data[datalen + keylen - 1] = '\0';

  int codelen = datalen + keylen - 1; //lenght of appended data word

  char temp[20], rem[20];

  for (int i = 0; i < keylen; i++)
    rem[i] = data[i]; //considering n bits of data for each step of binary division/EXOR 

  for (int j = keylen; j <= codelen; j++) {
    for (int i = 0; i < keylen; i++)
      temp[i] = rem[i]; // remainder of previous step is divident of current step

    if (rem[0] == '0') //if 1's bit of remainder is 0 then shift the rem by 1 bit
    {
      for (int i = 0; i < keylen - 1; i++)
        rem[i] = temp[i + 1];
    } else //else exor the divident with generator key
    {
      for (int i = 0; i < keylen - 1; i++)
        rem[i] = exor(temp[i + 1], key[i + 1]);

    }
    if (j != codelen)
      rem[keylen - 1] = data[j]; //appending next bit of data to remainder obtain by division
    else
      rem[keylen - 1] = '\0';
  }

  for (int i = 0; i < keylen - 1; i++)
    data[datalen + i] = rem[i]; //replace n-1 zeros with n-1 bit CRC
  data[codelen] = '\0';
  cout << "CRC=" << rem << "\nDataword=" << data;

}

int main() {
  char key[20], data[20];

  cout << "<----------Cyclic Redundancy Check Code---------->\n\n";
  cout << "Enter the data:";
  cin >> data;
  cout << "Enter the key:";
  cin >> key;

  crc(data, key); // generate crc

  return 0;
}
----
Stop and Wait Control
#include<iostream>
#include <time.h>
#include <cstdlib>
#include<ctime>
#include <unistd.h>
using namespace std;
class timer {
    private:
     unsigned long begTime;
    public:
     void start() {
      begTime = clock();
     }
  unsigned long elapsedTime() {
      return ((unsigned long) clock() - begTime) / CLOCKS_PER_SEC;
    }
   bool isTimeout(unsigned long seconds) {
      return seconds >= elapsedTime();
     }
};
int main()
{
 int frames[] = {1,2,3,4,5,6,7,8,9,10};
 unsigned long seconds = 5;
 srand(time(NULL));
 timer t;
 cout<<"Sender has to send frames : ";
 for(int i=0;i<10;i++)
     cout<<frames[i]<<" ";
 cout<<endl;
 int count = 0;
 bool delay = false;
 cout<<endl<<"Sender\t\t\t\t\tReceiver"<<endl;
 do
 {
     bool timeout = false;
     cout<<"Sending Frame : "<<frames[count];
     cout.flush();
     cout<<"\t\t";
     t.start();
     if(rand()%2)
     {
         int to = 24600 + rand()%(64000 - 24600)  + 1;
         for(int i=0;i<64000;i++)
             for(int j=0;j<to;j++) {}
     }
     if(t.elapsedTime() <= seconds)
     {
         cout<<"Received Frame : "<<frames[count]<<" ";
         if(delay)
         {
             cout<<"Duplicate";
             delay = false;
         }
         cout<<endl;
         count++;
     }
     else
     {
         cout<<"---"<<endl;
         cout<<"Timeout"<<endl;
         timeout = true;
     }
     t.start();
     if(rand()%2 || !timeout)
     {
         int to = 24600 + rand()%(64000 - 24600)  + 1;
         for(int i=0;i<64000;i++)
             for(int j=0;j<to;j++) {}
         if(t.elapsedTime() > seconds )
         {
             cout<<"Delayed Ack"<<endl;
             count--;
             delay = true;
         }
         else if(!timeout)
             cout<<"Acknowledgement : "<<frames[count]-1<<endl;
     }
 }while(count!=10);
 return 0;
}
----
Go back N
#include<iostream>
#include<ctime>
#include<cstdlib>
using namespace std;
int main()
{
 int nf,N;
 int no_tr=0;
 srand(time(NULL));
 cout<<"Enter the number of frames : ";
 cin>>nf;
 cout<<"Enter the Window Size : ";
 cin>>N;
 int i=1;
 while(i<=nf)
 {
     int x=0;
     for(int j=i;j<i+N && j<=nf;j++)
     {
         cout<<"Sent Frame "<<j<<endl;
         no_tr++;
     }
     for(int j=i;j<i+N && j<=nf;j++)
     {
         int flag = rand()%2;
         if(!flag)
             {
                 cout<<"Acknowledgment for Frame "<<j<<endl;
                 x++;
             }
         else
             {   cout<<"Frame "<<j<<" Not Received"<<endl;
                 cout<<"Retransmitting Window"<<endl;
                 break;
             }
     }
     cout<<endl;
     i+=x;
 }
 cout<<"Total number of transmissions : "<<no_tr<<endl;
 return 0;
}
----
Selective Repeat
#include<iostream>
using namespace std;
#include<conio.h>

#include<stdlib.h>

#include<time.h>

#include<math.h>



#define TOT_FRAMES 500

#define FRAMES_SEND 10



class sel_repeat

{

private:

int fr_send_at_instance;

int arr[TOT_FRAMES];

int send[FRAMES_SEND];

int rcvd[FRAMES_SEND];

char rcvd_ack[FRAMES_SEND];

int sw;

int rw;       //tells expected frame

public:

void input();

void sender(int);

void receiver(int);

};

void sel_repeat::input()

{

int n;     //no. of bits for the frame

int m;    //no. of frames from n bits
int i;
cout<<"Enter the no. of bits for the sequence no. : ";

cin>>n;

m=pow(2,n);

int t=0;

fr_send_at_instance=(m/2);

for(i=0;i<TOT_FRAMES;i++)

{

arr[i]=t;

t=(t+1)%m;

}

for(i=0;i<fr_send_at_instance;i++)

{

send[i]=arr[i];

rcvd[i]=arr[i];

rcvd_ack[i]='n';

}

rw=sw=fr_send_at_instance;

sender(m);

}

void sel_repeat::sender(int m)

{

for(int i=0;i<fr_send_at_instance;i++)

{

if(rcvd_ack[i]=='n')

cout<<"SENDER : Frame "<<send[i]<<" is sent\n";

}

receiver(m);

}

void sel_repeat::receiver(int m)

{

time_t t;

int f;
int j;
int f1;

int a1;

char ch;

srand((unsigned)time(&t));

for(int i=0;i<fr_send_at_instance;i++)

{

if(rcvd_ack[i]=='n')

{

f=rand()%10;

//if f=5 frame is discarded for some reason

//else frame is correctly recieved

if(f!=5)

{

for(int j=0;j<fr_send_at_instance;j++)

if(rcvd[j]==send[i])

{

cout<<"reciever:Frame"<<rcvd[j]<<"recieved correctly\n";

rcvd[j]=arr[rw];

rw=(rw+1)%m;

break;

}
int j;
if(j==fr_send_at_instance)

cout<<"reciever:Duplicate frame"<<send[i]<<"discarded\n";

a1=rand()%5;

//if al==3 then ack is lost

//else recieved

if(a1==3)

{

cout<<"(acknowledgement "<<send[i]<<" lost)\n";

cout<<"(sender timeouts-->Resend the frame)\n";

rcvd_ack[i]='n';

}

else

{

cout<<"(acknowledgement "<<send[i]<<" recieved)\n";

rcvd_ack[i]='p';

}

}

else

{int ld=rand()%2;

//if =0 then frame damaged

//else frame lost

if(ld==0)

{

cout<<"RECEIVER : Frame "<<send[i]<<" is damaged\n";

cout<<"RECEIVER : Negative Acknowledgement "<<send[i]<<" sent\n";

}

else

{

cout<<"RECEIVER : Frame "<<send[i]<<" is lost\n";

cout<<"(SENDER TIMEOUTS-->RESEND THE FRAME)\n";

}

rcvd_ack[i]='n';

}

}

}

for(int j=0;j<fr_send_at_instance;j++)

{

if(rcvd_ack[j]=='n')

break;

}

int i=0;

for(int k=j;k<fr_send_at_instance;k++)

{

send[i]=send[k];

if(rcvd_ack[k]=='n')

rcvd_ack[i]='n';

else

rcvd_ack[i]='p';

i++;

}

if(i!=fr_send_at_instance)

{

for(int k=i;k<fr_send_at_instance;k++)

{

send[k]=arr[sw];

sw=(sw+1)%m;

rcvd_ack[k]='n';

}

}

cout<<"Want to continue";

cin>>ch;

cout<<"\n";

if(ch=='y')

sender(m);

else

exit(0);

}

int main()

{


sel_repeat sr;

sr.input();
}
----
Sliding Window
#include<iostream>
#include <time.h>
#include <cstdlib>
#include<ctime>
#include <unistd.h>
#include<conio.h>
#include<stdlib.h>
#include<math.h>

using namespace std;
#define TOT_FRAMES 50
#define FRAMES_SEND 10
class sel_repeat {
  private:
    int fr_send_at_instance;
  int arr[TOT_FRAMES];
  int send[FRAMES_SEND];
  int rcvd[FRAMES_SEND];
  char rcvd_ack[FRAMES_SEND];
  int sw;
  int rw;
  public:
    void input();
  void sender(int);
  void receiver(int);
  void case1();
  void case2();
};
void sel_repeat::input() {
  int n;
  int m;
  int i;
  cout << "Enter the number of bits : ";
  cin >> n;
  m = pow(2, n);
  int t = 0;
  fr_send_at_instance = (m / 2);
  for (i = 0; i < TOT_FRAMES; i++) {
    arr[i] = t;
    t = (t + 1) % m;
  }
  for (i = 0; i < fr_send_at_instance; i++) {
    send[i] = arr[i];
    rcvd[i] = arr[i];
    rcvd_ack[i] = 'n';
  }
  rw = sw = fr_send_at_instance;
  sender(m);
}
void sel_repeat::sender(int m) {
  for (int i = 0; i < fr_send_at_instance; i++) {
    if (rcvd_ack[i] == 'n')
      cout << "SENDER : Frame " << send[i] << " is sent\n";
  }
  receiver(m);
}
void sel_repeat::receiver(int m) {
  time_t t;
  int f;
  int j;
  int f1;
  int a1;
  char ch;
  srand((unsigned) time( & t));
  for (int i = 0; i < fr_send_at_instance; i++) {
    if (rcvd_ack[i] == 'n') {
      f = rand() % 10;
      if (f != 5) {
        for (int j = 0; j < fr_send_at_instance; j++)
          if (rcvd[j] == send[i]) {
            cout << "Reciever : Frame " <<
              rcvd[j] << " recieved correctly\n";
            rcvd[j] = arr[rw];
            rw = (rw + 1) % m;
            break;
          }
        int j;
        if (j == fr_send_at_instance)
          cout << "Reciever : Duplicate frame " <<
          send[i] << " discarded\n";
        a1 = rand() % 5;
        if (a1 == 3) {
          cout << "(Acknowledgement " << send[i] << " lost)\n";
          cout << "(Sender timeouts --> Resend the frame)\n";
          rcvd_ack[i] = 'n';
        } else {
          cout << "(Acknowledgement " << send[i] << " recieved)\n";
          rcvd_ack[i] = 'p';
        }
      } else {
        int ld = rand() % 2;
        if (ld == 0) {
          cout << "RECEIVER : Frame " << send[i] <<
            " is damaged\n";
          cout << "RECEIVER : Negative Acknowledgement " <<
            send[i] << " sent\n";
        } else {
          cout << "RECEIVER : Frame " << send[i] << " is lost\n";
          cout << "(Sender timeouts --> Resend the frame)\n";
        }
        rcvd_ack[i] = 'n';
      }
    }
  }
  for (int j = 0; j < fr_send_at_instance; j++) {
    if (rcvd_ack[j] == 'n')
      break;
  }
  int i = 0;
  for (int k = j; k < fr_send_at_instance; k++) {
    send[i] = send[k];
    if (rcvd_ack[k] == 'n')
      rcvd_ack[i] = 'n';
    else
      rcvd_ack[i] = 'p';
    i++;
  }
  if (i != fr_send_at_instance) {
    for (int k = i; k < fr_send_at_instance; k++) {
      send[k] = arr[sw];
      sw = (sw + 1) % m;
      rcvd_ack[k] = 'n';
    }
  }
  cout << "Want to continue? Yes:y\t No:n\n";
  cin >> ch;
  cout << "\n";
  if (ch == 'y')
    sender(m);
}
void sel_repeat::case1() {
  int n, m, i;
  cout << "Enter the number of bits : ";
  cin >> n;
  m = pow(2, n);
  int t = 0;
  fr_send_at_instance = (m / 2);
  for (i = 0; i < TOT_FRAMES; i++) {
    arr[i] = t;
    t = (t + 1) % m;
  }
  for (i = 0; i < fr_send_at_instance; i++) {
    send[i] = arr[i];
    rcvd[i] = arr[i];
    rcvd_ack[i] = 'n';
  }
  rw = sw = fr_send_at_instance;
  for (int i = 0; i < fr_send_at_instance; i++) {
    if (rcvd_ack[i] == 'n')
      cout << "SENDER : Frame " << send[i] << " is sent\n";
  }
  time_t ti;
  int f, j, f1, a1;
  char ch;
  srand((unsigned) time( & ti));
  for (int i = 0; i < fr_send_at_instance; i++) {
    if (rcvd_ack[i] == 'n') {
      f = rand() % 10;
      for (int j = 0; j < fr_send_at_instance; j++)
        if (rcvd[j] == send[i]) {
          cout << "Reciever : Frame " << rcvd[j] <<
            " recieved correctly\n";
          rcvd[j] = arr[rw];
          rw = (rw + 1) % m;
          break;
        }
      int j;
      if (j == fr_send_at_instance)
        cout << "Reciever : Duplicate frame " <<
        send[i] << " discarded\n";
      cout << "(Acknowledgement " << send[i] << " recieved)\n";
      rcvd_ack[i] = 'p';
    }
  }
}
void sel_repeat::case2() {
  int n, m, i;
  cout << "Enter the number of bits : ";
  cin >> n;
  m = pow(2, n);
  int t = 0;
  fr_send_at_instance = (m / 2);
  for (i = 0; i < TOT_FRAMES; i++) {
    arr[i] = t;
    t = (t + 1) % m;
  }
  for (i = 0; i < fr_send_at_instance; i++) {
    send[i] = arr[i];
    rcvd[i] = arr[i];
    rcvd_ack[i] = 'n';
  }
  rw = sw = fr_send_at_instance;
  for (int i = 0; i < fr_send_at_instance; i++) {
    if (rcvd_ack[i] == 'n')
      cout << "SENDER : Frame " << send[i] << " is sent\n";
  }
  time_t ti;
  int f, j, f1, a1;
  char ch;
  srand((unsigned) time( & ti));
  for (int i = 0; i < fr_send_at_instance; i++) {
    if (rcvd_ack[i] == 'n') {
      f = rand() % 10;
      if (f != 5) {
        for (int j = 0; j < fr_send_at_instance; j++)
          if (rcvd[j] == send[i]) {
            cout << "Reciever : Frame " <<
              rcvd[j] << " recieved correctly\n";
            rcvd[j] = arr[rw];
            rw = (rw + 1) % m;
            break;
          }
        int j;
        if (j == fr_send_at_instance)
          cout << "Reciever : Duplicate frame " <<
          send[i] << " discarded\n";
        a1 = rand() % 5;
        if (a1 == 3) {
          cout << "(Acknowledgement " <<
            send[i] << " lost)\n";
          cout << "(Sender timeouts --> Resend the frame)\n";
          rcvd_ack[i] = 'n';
        } else {
          cout << "(Acknowledgement " <<
            send[i] << " recieved)\n";
          rcvd_ack[i] = 'p';
        }
      } else {
        int ld = rand() % 2;
        if (ld == 0) {
          cout << "RECEIVER : Frame " <<
            send[i] << " is damaged\n";
          cout << "RECEIVER : Negative Acknowledgement " <<
            send[i] << " sent\n";
        } else {
          cout << "RECEIVER : Frame " <<
            send[i] << " is lost\n";
          cout << "(Sender timeouts --> Resend the frame)\n";
        }
        rcvd_ack[i] = 'n';
      }
    }
  }
  for (int j = 0; j < fr_send_at_instance; j++) {
    if (rcvd_ack[j] == 'n')
      break;
  }
  i = 0;
  for (int k = j; k < fr_send_at_instance; k++) {
    send[i] = send[k];
    if (rcvd_ack[k] == 'n')
      rcvd_ack[i] = 'n';
    else
      rcvd_ack[i] = 'p';
    i++;
  }
  if (i != fr_send_at_instance) {
    for (int k = i; k < fr_send_at_instance; k++) {
      send[k] = arr[sw];
      sw = (sw + 1) % m;
      rcvd_ack[k] = 'n';
    }
  }
  cout << "Want to continue? Yes:y\t No:n\n";
  cin >> ch;
  cout << "\n";
  if (ch == 'y')
    sender(m);
}
int main() {
  cout << "\n<----------Sliding Window Mechanism---------->\n";
  char choice;
  int v;
  do {
    cout << "\n\n1) Stop and Wait ARQ \n";
    cout << "2) Go Back N ARQ \n";
    cout << "3) Selective Repeat ARQ \n";
    cout << "4) Exit \n";
    cout << "\nEnter your choice: ";
    cin >> choice;
    switch (choice) {
    case '1': {
      int surviveStatus, Frame;
      cout << "\nEnter Frame to transmit: ";
      cin >> Frame;
      resendSNW:
        //In Internet frames lost
        cout << "\n\n------ Some Frame Lost ------";
      cout << "\n--> Should this frame survive?(1/0) -> ";
      cin >> surviveStatus;
      if (surviveStatus) {
        cout << "-- Above Frames received --\n";
        cout << "-- Acknowledgment of above frames sent by receiver --\n\n";
      } else {
        cout << "-- No Frames received --\n";
        cout << "-- No Acknowledgment of frames sent by receiver --\n\n";
        cout << "-- After Timer Expire on sender end, frame is resend --\n";
        goto resendSNW;
      }
    }
    break;
    case '2': {
      int nf, N;
      int no_tr = 0;
      srand(time(NULL));
      cout << "Enter the number of frames : ";
      cin >> nf;
      cout << "Enter the Window Size : ";
      cin >> N;
      int i = 1;
      while (i <= nf) {
        int x = 0;
        for (int j = i; j < i + N && j <= nf; j++) {
          cout << "Sent Frame " << j << endl;
          no_tr++;
        }
        for (int j = i; j < i + N && j <= nf; j++) {
          int flag = rand() % 2;
          if (!flag) {
            cout << "Acknowledgment for Frame " << j << endl;
            x++;
          } else {
            cout << "Frame " << j << " Not Received" << endl;
            cout << "Retransmitting Window" << endl;
            break;
          }
        }
        cout << endl;
        i += x;
      }
      cout << "Total number of transmissions : " << no_tr << endl;
      //return 0;
    }
    break;
    case '3': {
      sel_repeat sr;
      int a = 1;
      while (a <= 2) {
        cout << "1.Print Acknowledgment" << endl;
        cout << "2.Print the frame lost" << "and retransmit frames if asked" << endl;
        cout << "3.Exit" << endl;
        cout << "Enter your choice: ";
        cin >> a;
        switch (a) {
        case 1:
          sr.case1();
          break;
        case 2:
          sr.case2();
          break;
        default:
          break;
        }
      }
    }
    break;
    case '4':
      exit(0);
      break;
    default:
      cout << "Invalid choice!!";
    }
  } while (choice != '0');
}
----
Subnet Calculator
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <stdio.h>
#include <math.h>
using namespace std;



int getOctetsIP(string ip, vector<int> &octetsIP) {		// Define vector<int> octets, using reference from main
	stringstream sip(ip);								// use stringstream named ss and populate with ip
	string temp;
	octetsIP.clear();									// Clears the octetsMask vector, in case main function re-runs this function
	vector<bool> ipInRange;
	while (getline(sip,temp,'.'))						// Every time getline recieves new stream element from ss, save to temp
		octetsIP.push_back(atoi(temp.c_str()));			//... until reaches '.' delimiter, then push_back octet with new element.
	if (octetsIP.size() == 4) {
		for(int i = 0; i < octetsIP.size(); i++){
			if (octetsIP[i] >= 0 && octetsIP[i] <= 255)
				ipInRange.push_back(true);
			else
				ipInRange.push_back(false);
		}
		if (ipInRange[0]==true&&ipInRange[1]==true&&ipInRange[2]==true&&ipInRange[3]==true){
			return 0;
		}else{
			cout << endl << "There are only 255 bits per octet. Please re-enter IP." << endl << endl;
			return 1;
		}
	}else{
		cout << endl << "Please enter four octets in dot notation." << endl << endl;
		return 1;
	}
}




int getOctetsMask(string mask,  vector<int> &octetsMask) {
	stringstream smask(mask);
	string temp;
	octetsMask.clear();		// Clears the octetsMask vector, in case main function re-runs this function
	vector<bool> maskInRange;
	while (getline(smask,temp,'.'))
		octetsMask.push_back(atoi(temp.c_str()));
	if (octetsMask.size() == 4){
		for(int i = 0; i < octetsMask.size(); i++){
			if (octetsMask[i] == 0 || octetsMask[i] == 128 || octetsMask[i] == 192 || octetsMask[i] == 224 || octetsMask[i] == 240 || octetsMask[i] == 248 || octetsMask[i] == 252 || octetsMask[i] == 254 || octetsMask[i] == 255)
				maskInRange.push_back(true);
			else
				maskInRange.push_back(false);
		}
		if(maskInRange[0]==true&&maskInRange[1]==true&&maskInRange[2]==true&&maskInRange[3]==true){
			return 0;
		}else{
			cout << endl << "Subnet masks only use 2^[0-7]. Please re-enter mask." << endl << endl;
			return 1;
		}
	}else{
		cout << endl << "Please enter four octets in dot notation." << endl << endl;
		return 1;
	}
}




int calcClass(vector<int> &octetsIP) {
	if (octetsIP[0] == 10) {
		return 1;	// Class A Private address blocks //
	}else if (octetsIP[0] == 172 && octetsIP[1] >= 16 && octetsIP[1] <= 31) {
		return 2;	// Class B Private address blocks //
	}else if (octetsIP[0] == 192 && octetsIP[1] == 168) {
		return 3;	// Class C Private address blocks //
	}else if (octetsIP[0] == 127) {
		return 4;	// Loopback Address Reserved address blocks //
	}else if (octetsIP[0] >= 0 && octetsIP[0] < 127) {
		return 5;
	}else if (octetsIP[0] > 127 && octetsIP[0] < 192) {
		return 6;
	}else if (octetsIP[0] > 191 && octetsIP[0] < 224) {
		return 7;
	}else if (octetsIP[0] > 223 && octetsIP[0] < 240) {
		return 8;
	}else if (octetsIP[0] > 239 && octetsIP[0] <= 255) {
		return 9;
	}else{
		return 0;	// Out of Range //
	}
}




// Determine Binary /--
int getNHBits(vector<int> &octetsIP, vector<int> &octetsMask, vector<int> &octetsIPBits, vector<int> &octetsMaskBits){

	// Get IP binary rep. //
cout << "------------------------------------------" << endl;
cout << "///////// Binary Representation //////////" << endl;
cout << "------------------------------------------" << endl;
	for (int j=0; j < octetsIP.size(); j++)
    {
		if (j>0)
			cout << ".";

        int mask = 128;
        while (mask)
        {
            octetsIPBits.push_back((octetsIP[j] & mask) != 0);
			cout << ((octetsIP[j] & mask) != 0);
            mask >>= 1;
        }
    }
	cout << "  : IP Address" << endl;

	// Get SUBNET binary rep. //
	for (int j=0; j < octetsMask.size(); j++)
    {
		if (j>0)
			cout << ".";
        int mask = 128;
        while (mask)
        {
            octetsMaskBits.push_back((octetsMask[j] & mask) != 0);
			cout << ((octetsMask[j] & mask) != 0);
            mask >>= 1;
        }
    }
	cout << "  : Subnet Mask" << endl;
	cout << "-----------------------------------------" << endl;

return 0;
}



// Perform ANDing of IP and Subnet Mask to generate Network ID range //
vector<int> getNetID(vector<int> &octetsIPBits, vector<int> &octetsMaskBits){
	vector<int> netID;
    for (int j=0; j < octetsIPBits.size(); j++)
    {
        if ((j > 0) && (j%8 == 0))
            cout << ".";

		netID.push_back(octetsIPBits[j] & octetsMaskBits[j]);
    }
return netID;
}


// Turn Binary back to Decimal
string toString(vector<int> octets){
	ostringstream octStrm;

	for(int j = 0; j < octets.size(); j++)
	{
		if (j>0)
			octStrm << '.';

		octStrm << octets[j];
	}

	return octStrm.str();
}


// Turn Binary back to Decimal
vector<int> toDecimal(vector<int> octets, vector<int> &decimals){
	stringstream octStrm;
	decimals.clear();
	for(int j = 0; j < octets.size(); j++)
	{
		if (j>0)
			octStrm << '.';

		octStrm << octets[j];
	}

	string temp;
	while (getline(octStrm, temp, '.'))
		decimals.push_back(atoi(temp.c_str()));

	return decimals;
}

// Get the network increment //
int getIncrement(vector<int> decimalMask, vector<int> decimalNetID){
	int increment = 0;
	for (int i=0; i<decimalMask.size(); i++){
		if (decimalMask[i] == 255){
			increment = 1;
		}else if(decimalMask[i] == 254){
			increment = 2;
			break;
		}else if(decimalMask[i] == 252){
			increment = 4;
			break;
		}else if(decimalMask[i] == 248){
			increment = 8;
			break;
		}else if(decimalMask[i] == 240){
			increment = 16;
			break;
		}else if(decimalMask[i] == 224){
			increment = 32;
			break;
		}else if(decimalMask[i] == 192){
			increment = 64;
			break;
		}else if(decimalMask[i] == 128){
			increment = 128;
			break;
		}
	}
return increment;
}

// get network id range
vector<int> getNetIDRange(vector<int> &decimalNetID, int &netInc, vector<int> &decimalMask) {
	vector<int> netIDEnd;
	for (int i=0; i<decimalNetID.size(); i++){
		if (decimalMask[i] == 255){
			netIDEnd.push_back(decimalNetID[i]);
		}else if (decimalMask[i] < 255 && decimalMask[i] > 0){
			netIDEnd.push_back( (decimalNetID[i] + netInc) - 1 );
		}else{
			netIDEnd.push_back(255);
		}
	}
	return netIDEnd;
}



// Get subnets
int getSubnets(vector<int> &decimalMask, int &ipClass, vector<int> &subClassMask){
	int netBits = 0;
	subClassMask.clear();
		if (ipClass==1){
			subClassMask.push_back(255);
			subClassMask.push_back(0);
			subClassMask.push_back(0);
			subClassMask.push_back(0);
		}else if(ipClass==2){
			subClassMask.push_back(255);
			subClassMask.push_back(255);
			subClassMask.push_back(0);
			subClassMask.push_back(0);
		}else if(ipClass==3){
			subClassMask.push_back(255);
			subClassMask.push_back(255);
			subClassMask.push_back(255);
			subClassMask.push_back(0);
		}else if(ipClass==4 || ipClass==5){
			subClassMask.push_back(decimalMask[0]);
			subClassMask.push_back(decimalMask[1]);
			subClassMask.push_back(decimalMask[2]);
			subClassMask.push_back(decimalMask[3]);
		}

	for (int i=0; i<decimalMask.size(); i++){
		if (decimalMask[i] != subClassMask[i]){
			if (decimalMask[i] == 255){
				netBits += 8;
				continue;
			}else if (decimalMask[i] == 254){
				netBits += 7;
				continue;
			}else if (decimalMask[i] == 252){
				netBits += 6;
				continue;
			}else if (decimalMask[i] == 248){
				netBits += 5;
				continue;
			}else if (decimalMask[i] == 240){
				netBits += 4;
				continue;
			}else if (decimalMask[i] == 224){
				netBits += 3;
				continue;
			}else if (decimalMask[i] == 192){
				netBits += 2;
				continue;
			}else if (decimalMask[i] == 128){
				netBits += 1;
				continue;
			}else if (decimalMask[i] == 0){
				netBits += 0;
				continue;
			}else{
				netBits += 0;
			}
		}
	}
	int subnets = pow(2.0,netBits);
	return subnets;
}



// Get hosts per subnet
int getHostsPerSubnet(vector<int> &decimalMask){
	int hostBits = 0;
	for (int i=0; i<decimalMask.size(); i++){
		if (decimalMask[i] == 255){
			hostBits += 0;
			continue;
		}else if (decimalMask[i] == 254){
			hostBits += 1;
			continue;
		}else if (decimalMask[i] == 252){
			hostBits += 2;
			continue;
		}else if (decimalMask[i] == 248){
			hostBits += 3;
			continue;
		}else if (decimalMask[i] == 240){
			hostBits += 4;
			continue;
		}else if (decimalMask[i] == 224){
			hostBits += 5;
			continue;
		}else if (decimalMask[i] == 192){
			hostBits += 6;
			continue;
		}else if (decimalMask[i] == 128){
			hostBits += 7;
			continue;
		}else if (decimalMask[i] == 0){
			hostBits += 8;
			continue;
		}else{
			hostBits = 0;
			break;
		}
	}
	int hostsPerSubnet = pow(2.0,hostBits)-2;
	return hostsPerSubnet;
}


int main() {

// Give details, given an IP and Subnet Mask //
char resp = 'y';
while (resp == 'y') {
	cout << " //// -- IPv4 Subnetting Calculator -- \\\\\\\\" << endl;
	cout << endl << endl;

		// Get IP address octets //
		string ip;
		vector<int> octetsIP;
		while (getOctetsIP(ip, octetsIP) == 1) {
		cout << "Enter IPv4 Address -> ";
		(getline(cin, ip));		// Accept user input for IP Address //
		}

		// Get subnet mask octets //
		string mask;
		vector<int> octetsMask;
		while (getOctetsMask(mask, octetsMask) == 1) {
		cout << endl << "Enter subnet mask for " << ip << " -> ";
		(getline(cin, mask));	// Accept user input for subnet mask //
		}
		cout << endl << endl << endl << endl << endl;

		// Print Initial User IP and Subnet Mask //
		vector<int> decimals;
		cout << "//////////////////////////////////////////" << endl;
		cout << "/// IP Address: " << toString(octetsIP) << endl;
		vector<int> decimalMask = toDecimal(octetsMask, decimals);
		cout << "/// Subnet Mask: " << toString(octetsMask) << endl;
		cout << "//////////////////////////////////////////" << endl << endl;

		// Print Binary Representation //
		vector<int> octetsIPBits;
		vector<int> octetsMaskBits;
		getNHBits(octetsIP, octetsMask, octetsIPBits, octetsMaskBits);
		vector<int> netID = getNetID(octetsIP, octetsMask);
		vector<int> decimalNetID = toDecimal(netID, decimals);
		int netInc = getIncrement(decimalMask, decimalNetID);
		cout << endl;

		// Print IP Class
			// Run function to determine and print IP class
			cout << "------------------------------------------" << endl;
			cout << "//////////// Class Information ///////////" << endl;
			cout << "------------------------------------------" << endl;
			int classResult = calcClass(octetsIP);
			int ipClass = 0;
			switch (classResult){
				case 1:
					cout << "IP Class: Private block, Class 'A' " << endl;
					ipClass = 1;
					break;
				case 2:
					cout << "IP Class: Private block, Class 'B'" << endl;
					ipClass = 2;
					break;
				case 3:
					cout << "IP Class: Private block, Class 'C'" << endl;
					ipClass = 3;
					break;
				case 4:
					cout << "IP Class: Reserved block, System Loopback Address" << endl;
					ipClass = 1;
					break;
				case 5:
					cout << "IP Class: A" << endl;
					ipClass = 1;
					break;
				case 6:
					cout << "IP Class: B" << endl;
					ipClass = 2;
					break;
				case 7:
					cout << "IP Class: C" << endl;
					ipClass = 3;
					break;
				case 8:
					cout << "IP Class: D" << endl;
					ipClass = 4;
					cout << "!! This is a reserved Class D Multicast IP Address Block" << endl;
					break;
				case 9:
					cout << "IP Class: E" << endl;
					ipClass = 5;
					cout << "!! This is a reserved Class E Multicast IP Address Block" << endl;
					break;
				default :
					cout << "Not in Range" << endl;
					break;
			}
		vector<int> subClassMask;
		getSubnets(decimalMask, ipClass, subClassMask);
		cout << "Default Class Subnet Mask: " << toString(subClassMask) << endl;
		cout << "-----------------------------------------" << endl << endl;

		// Print Subnetting Details //
		cout << "------------------------------------------" << endl;
		cout << "///////////// Subnet Details /////////////" << endl;
		cout << "------------------------------------------" << endl;
		vector<int> netIDRange = getNetIDRange(decimalNetID, netInc, decimalMask);
		cout << "Network ID:            -           Broadcast ID: " << endl;
			cout << "-------------------------------------------------" << endl;
			cout << toString(netID) << " - [ usable hosts ] - ";
		cout << toString(netIDRange) << endl << endl;
		cout << "Network Increment: " << getIncrement(decimalMask, decimalNetID) << endl;
		cout << "Number of Subnets: " << getSubnets(decimalMask, ipClass, subClassMask) << endl;
		cout << "Usable hosts per subnet: " << getHostsPerSubnet(decimalMask) << endl;
		cout << "-----------------------------------------" << endl << endl;

		cout << "Would you like to enter another IP Address to subnet? (y or n): ";
		cin >> resp;
		cout << endl << endl << endl << endl;
}
	return 0;
}
----
Subnet Calculator 2
#include <iostream>
#include <sstream>
#include <locale>
#include <vector>
#include <iterator>
#include <math.h>
using namespace std;

//Code for parsing ip string
struct dot_ws : ctype<char> 
{
    static const mask* make_table() 
    {
        static vector<mask> v(classic_table(), classic_table() + table_size);
        v['.'] |= space;
        v['/'] |= space;
        return &v[0];
    }
    dot_ws(size_t refs = 0) : ctype(make_table(), false, refs) {}
};

int subnet_calculator(int a)
{
    int num;

    if(a == 1)
        num = 128;
    if(a == 2)
        num = 192;
    if(a == 3)
        num = 224;
    if(a == 4)
        num = 240;
    if(a == 5)
        num = 248;
    if(a == 6)
        num = 252;
    if(a == 7)
        num = 254;

    return num;
}

int convertBinaryToDecimal(long long n)
{
    int decimalNumber = 0, i = 0, remainder;
    while (n!=0)
    {
        remainder = n%10;
        n /= 10;
        decimalNumber += remainder*pow(2,i);
        ++i;
    }
    return decimalNumber;
}

int main()
{
    //Declaring and storing the IP entered by the user.
    string ip;
    char ipclass;
    int net_address_loop = 0, temp, subnet_mask, subnet_loop;

    cout << "Enter an IP address: ";
    cin >> ip;

    ///////////PARSING IP ADDRESS///////////////////
    istringstream ins(ip);
    ins.imbue(locale(ins.getloc(), new dot_ws()));
    istream_iterator<long> beg(ins), end;
    vector<long> vec(beg, end);

    /////////FINDING THE CLASS OF THE IP////////////
    if(vec[0] <= 127)
    {
        ipclass = 'A';
        net_address_loop = 1;
    }
    else if(vec[0] >= 128 && vec[0] <= 191)
    {
        ipclass = 'B';
        net_address_loop = 2;
    }
    else if(vec[0] >= 192 && vec[0] <= 223)
    {
        ipclass = 'C';
        net_address_loop = 3;
    }

    ////////////FINDING THE SUBNET MASK///////////
    subnet_mask = vec[4] / 8;
    subnet_loop = subnet_mask;
    subnet_mask = vec[4] - (8 * subnet_mask);
    subnet_mask = subnet_calculator(subnet_mask);

    ///////////////CALCULATING SUBNET/////////////
    int sub_mask[8];
    int ip_add[8];
    int ip_add2[8];
    int sub_ip_add[8];
    int mask = subnet_mask;
    int subnet, counter = 0;
    stringstream ss;

    for(int i = 0; mask > 0; i++)    
    {    
        sub_mask[i] = mask % 2;    
        mask /= 2;  
    }

    if(vec[4] < 8)
        subnet = vec[0];
    if(vec[4] >= 8 && vec[4] < 16)
        subnet = vec[1];
    if(vec[4] >= 16 && vec[4] < 24)
        subnet = vec[2];
    if(vec[4] >= 24 && vec[4] < 32)
        subnet = vec[3];
    
    for(int i = 0; subnet > 0; i++)    
    {    
        sub_ip_add[i] = subnet % 2;    
        subnet /= 2;  
    }

    for(int i = 0; i < 8; i++)
    {
        if(sub_ip_add[i] == 1 || sub_ip_add[i] == 0)
        {

        }
        else
        {
            sub_ip_add[i] = 0;
        }
    }

    for(int i = 0; i < 8; i++)
    {
        if(sub_ip_add[i] == 1 && sub_mask[i] == 1)
        {
            ip_add[i] = 1;
        }
        else
        {
            ip_add[i] = 0;
        }
    }

    for(int i = 7; i >= 0; i--)
    {
        ip_add2[counter] = ip_add[i];
        counter++;
    }

    for (unsigned i = 0; i < sizeof ip_add2 / sizeof ip_add2[0]; ++i)
        ss << ip_add2[i];
    
    ss >> subnet;

    subnet = convertBinaryToDecimal(subnet);

    ////////CALCULATING SUBNET BROADCAST//////////
    int broadcast, b_temp;

    broadcast = 256 - subnet_mask;

    broadcast = broadcast + subnet - 1;
    ////////////////PRINTING INFO/////////////////
    
    cout << "Class Type: " << ipclass << endl;

    cout << "Classfull Network Address: ";
    if(net_address_loop == 1)
        cout << vec[0] << ".0.0.0" << endl;
    if(net_address_loop == 2)
        cout << vec[0] << "." << vec[1] << ".0.0" << endl;
    if(net_address_loop == 3)
        cout << vec[0] << "." << vec[1] << "." << vec[2] << ".0" << endl;

    cout << "Classfull Broadcast Address: ";
    if(net_address_loop == 1)
        cout << vec[0] << ".255.255.255" << endl;
    if(net_address_loop == 2)
        cout << vec[0] << "." << vec[1] << ".255.255" << endl;
    if(net_address_loop == 3)
        cout << vec[0] << "." << vec[1] << "." << vec[2] << ".255" << endl;

    cout << "Subnet Mask: ";
    if(subnet_loop == 0)
        cout << subnet_mask << ".0.0.0" << endl;
    else if(subnet_loop == 1)
        cout << "255." << subnet_mask << ".0.0" << endl;
    else if(subnet_loop == 2)
        cout << "255.255." << subnet_mask << ".0" << endl;
    else if(subnet_loop == 3)
        cout << "255.255.255." << subnet_mask << endl;
    
    cout << "Subnet: ";
    if(vec[4] < 8)
        cout << subnet << ".0.0.0" << endl;
    if(vec[4] >= 8 && vec[4] < 16)
        cout << vec[0] << "." << subnet << ".0.0" << endl;
    if(vec[4] >= 16 && vec[4] < 24)
        cout << vec[0] << "." << vec[1] << "." << subnet << ".0" << endl;
    if(vec[4] >= 24 && vec[4] < 32)
        cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << subnet << endl;

    cout << "Subnet Broadcast: ";
    if(vec[4] < 8)
        cout << broadcast << ".255.255.255" << endl;
    if(vec[4] >= 8 && vec[4] < 16)
        cout << vec[0] << "." << broadcast << ".255.255" << endl;
    if(vec[4] >= 16 && vec[4] < 24)
        cout << vec[0] << "." << vec[1] << "." << broadcast << ".255" << endl;
    if(vec[4] >= 24 && vec[4] < 32)
        cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << broadcast << endl;
        
    cout << "Number of usable Hosts: ";
    int hosts;
    hosts = 32 - vec[4];
    hosts = pow(2, hosts);
    cout << hosts - 2 << endl;

    cout << "Number of usable Subnets: ";
    int subnets = 32-vec[4];
    if(ipclass == 'A')
        subnets = 24 - subnets;
    if(ipclass == 'B')
        subnets = 16 - subnets;
    if(ipclass == 'C')
        subnets = 8 - subnets;
    cout << pow(2, subnets) << endl;

    if(ipclass == 'A')
    {
        cout << "Host Range Starting: ";
        if(vec[4] < 8)
            cout << subnet << ".0.0.1" << endl;
        if(vec[4] >= 8 && vec[4] < 16)
            cout << vec[0] << "." << subnet << ".0.1" << endl;
        if(vec[4] >= 16 && vec[4] < 24)
            cout << vec[0] << "." << vec[1] << "." << subnet+1 << ".1" << endl;
        if(vec[4] >= 24 && vec[4] < 32)
            cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << subnet << endl;
    
        cout << "Host Range Ending: ";
        if(vec[4] < 8)
        cout << broadcast << ".255.255.254" << endl;
        if(vec[4] >= 8 && vec[4] < 16)
            cout << vec[0] << "." << broadcast << ".255.254" << endl;
        if(vec[4] >= 16 && vec[4] < 24)
            cout << vec[0] << "." << vec[1] << "." << broadcast << ".254" << endl;
        if(vec[4] >= 24 && vec[4] < 32)
            cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << broadcast-1 << endl;
    }

    if(ipclass == 'B')
    {
        cout << "Host Range Starting: ";
        if(vec[4] < 8)
            cout << subnet+1 << ".0.0.0" << endl;
        if(vec[4] >= 8 && vec[4] < 16)
            cout << vec[0] << "." << subnet+1 << ".0.0" << endl;
        if(vec[4] >= 16 && vec[4] < 24)
            cout << vec[0] << "." << vec[1] << "." << subnet+1 << ".0" << endl;
        if(vec[4] >= 24 && vec[4] < 32)
            cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << subnet+1 << endl;
    
        cout << "Host Range Ending: ";
        if(vec[4] < 8)
        cout << broadcast-1 << ".255.255.255" << endl;
        if(vec[4] >= 8 && vec[4] < 16)
            cout << vec[0] << "." << broadcast-1 << ".255.255" << endl;
        if(vec[4] >= 16 && vec[4] < 24)
            cout << vec[0] << "." << vec[1] << "." << broadcast-1 << ".255" << endl;
        if(vec[4] >= 24 && vec[4] < 32)
            cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << broadcast-1 << endl;
    }

    if(ipclass == 'C')
    {
        cout << "Host Range Starting: ";
        if(vec[4] < 8)
            cout << subnet+1 << ".0.0.0" << endl;
        if(vec[4] >= 8 && vec[4] < 16)
            cout << vec[0] << "." << subnet+1 << ".0.0" << endl;
        if(vec[4] >= 16 && vec[4] < 24)
            cout << vec[0] << "." << vec[1] << "." << subnet+1 << ".0" << endl;
        if(vec[4] >= 24 && vec[4] < 32)
            cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << subnet+1 << endl;
    
        cout << "Host Range Ending: ";
        if(vec[4] < 8)
        cout << broadcast-1 << ".255.255.255" << endl;
        if(vec[4] >= 8 && vec[4] < 16)
            cout << vec[0] << "." << broadcast-1 << ".255.255" << endl;
        if(vec[4] >= 16 && vec[4] < 24)
            cout << vec[0] << "." << vec[1] << "." << broadcast-1 << ".255" << endl;
        if(vec[4] >= 24 && vec[4] < 32)
            cout << vec[0] << "." << vec[1] << "." << vec[2] << "." << broadcast-1 << endl;
    }

    cout << "Is This A Usable Host: ";
    int failure = 0;
    if(vec[4] < 8)
        if(vec[0] < subnet+1)
            failure++;
    if(vec[4] >= 8 && vec[4] < 16)
        if(vec[1] < subnet+1)
            failure++;
    if(vec[4] >= 16 && vec[4] < 24)
        if(vec[2] < subnet+1)
            failure++;
    if(vec[4] >= 24 && vec[4] < 32)
        if(vec[3] < subnet+1)
            failure++;
    if(ipclass == 'A')
    {
        if(vec[4] < 8)
            if(vec[0] > broadcast-1)
                failure++;
        if(vec[4] >= 8 && vec[4] < 16)
            if(vec[1] > broadcast-1)
                failure++;
        if(vec[4] >= 16 && vec[4] < 24)
            if(vec[2] > broadcast)
                failure++;
        if(vec[4] >= 24 && vec[4] < 32)
            if(vec[3] > broadcast-1)
                failure++;
    }
    else
    {
        if(vec[4] < 8)
            if(vec[0] > broadcast-1)
                failure++;
        if(vec[4] >= 8 && vec[4] < 16)
            if(vec[1] > broadcast-1)
                failure++;
        if(vec[4] >= 16 && vec[4] < 24)
            if(vec[2] > broadcast-1)
                failure++;
        if(vec[4] >= 24 && vec[4] < 32)
            if(vec[3] > broadcast-1)
                failure++;
    }

    if(failure == 0)
        cout << "Yes!" << endl;
    else
        cout << "No!" << endl;
    
    return 0;
}

----
Distance Vector
#include<stdio.h>
#include<iostream>
using namespace std;
                                                          
struct node
{
    unsigned dist[6];
    unsigned from[6];
}DVR[10];
int main()
{
    cout<<"\n<----------DISTANCE VECTOR ROUTING ALGORITHM---------->";
    int costmat[6][6];
    int nodes, i, j, k;
    cout<<"\n\n Enter the number of nodes : ";
    cin>>nodes; //Enter the nodes
    cout<<"\n Enter the cost matrix : \n" ;
    for(i = 0; i < nodes; i++)
     {
        for(j = 0; j < nodes; j++)
        {
            cin>>costmat[i][j];
            costmat[i][i] = 0;
            DVR[i].dist[j] = costmat[i][j]; //initialise the distance equal to cost matrix
            DVR[i].from[j] = j;
        }
    }
            for(i = 0; i < nodes; i++) //We choose arbitary vertex k and we calculate the
            //direct distance from the node i to k using the cost matrix and add the distance from k to node j
            for(j = i+1; j < nodes; j++)
            for(k = 0; k < nodes; k++)
                if(DVR[i].dist[j] > costmat[i][k] + DVR[k].dist[j])
                {   //We calculate the minimum distance
                    DVR[i].dist[j] = DVR[i].dist[k] + DVR[k].dist[j];
                    DVR[j].dist[i] = DVR[i].dist[j];
                    DVR[i].from[j] = k;
                    DVR[j].from[i] = k;
                }
        for(i = 0; i < nodes; i++)
        {
            cout<<"\n\n For router: "<<i+1;
            for(j = 0; j < nodes; j++)
                cout<<"\t\n node "<<j+1<<" via "<<DVR[i].from[j]+1<<" Distance "<<DVR[i].dist[j];
        }
    cout<<" \n\n ";
    return 0;
}
----
1) Server
Code: #include <unistd.h>

  #include <stdio.h>

  #include <sys/socket.h>

  #include <stdlib.h>

  #include <netinet/in.h>

  #include <string.h>

  #define PORT 8080
int main(int argc, char
  const * argv[]) {
  int server_fd, new_socket, valread;
  struct sockaddr_in address;
  int opt = 1;
  int addrlen = sizeof(address);
  char buffer[1024] = {
    0
  };
  char * hello = "Hello from server";
  // Creating socket file descriptor
  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror("socket failed");
    exit(EXIT_FAILURE);
  }
  // Forcefully attaching socket to the port 8080
  if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &
      opt, sizeof(opt))) {
    perror("setsockopt");
    exit(EXIT_FAILURE);
  }
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(PORT);
  // Forcefully attaching socket to the port 8080
  if (bind(server_fd, (struct sockaddr * ) & address,
      sizeof(address)) < 0) {
    perror("bind failed");
    exit(EXIT_FAILURE);
  }
  if (listen(server_fd, 3) < 0) {
    perror("listen");
    exit(EXIT_FAILURE);
  }
  if ((new_socket = accept(server_fd, (struct sockaddr * ) & address,
      (socklen_t * ) & addrlen)) < 0) {
    perror("accept");
    exit(EXIT_FAILURE);
  }
  valread = read(new_socket, buffer, 1024);
  printf("%s\n", buffer);
  send(new_socket, hello, strlen(hello), 0);
  printf("Hello message sent\n");
  return 0;
}
----
2) Client
Code:
  // Client side C/C++ program to demonstrate Socket programming
  #include <stdio.h>

  #include <sys/socket.h>

  #include <arpa/inet.h>

  #include <unistd.h>

  #include <string.h>

  #define PORT 8080
int main(int argc, char
  const * argv[]) {
  int sock = 0, valread;
  struct sockaddr_in serv_addr;
  char * hello = "Hello from client";
  char buffer[1024] = {
    0
  };
  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    printf("\n Socket creation error \n");
    return -1;
  }
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port = htons(PORT);
  // Convert IPv4 and IPv6 addresses from text to binary form
  if (inet_pton(AF_INET, "127.0.0.1", & serv_addr.sin_addr) <= 0) {
    printf("\nInvalid address/ Address not supported \n");
    return -1;
  }
  if (connect(sock, (struct sockaddr * ) & serv_addr, sizeof(serv_addr)) < 0) {
    printf("\nConnection Failed \n");
    return -1;
  }
  send(sock, hello, strlen(hello), 0);
  printf("Hello message sent\n");
  valread = read(sock, buffer, 1024);
  printf("%s\n", buffer);
  return 0;
}
----
TCP & UDP
FOR TCP:-

TCP Client:-

#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>
 
int main(void)
{
  int sockfd = 0,n = 0;
  char recvBuff[1024];
  struct sockaddr_in serv_addr;
 
  memset(recvBuff, '0' ,sizeof(recvBuff));
  if((sockfd = socket(AF_INET, SOCK_STREAM, 0))< 0)
    {
      printf("\n Error : Could not create socket \n");
      return 1;
    }
 
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port = htons(5000);
  serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
 
  if(connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr))<0)
    {
      printf("\n Error : Connect Failed \n");
      return 1;
    }
 
  while((n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) > 0)
    {
      recvBuff[n] = 0;
      if(fputs(recvBuff, stdout) == EOF)
    {
      printf("\n Error : Fputs error");
    }
      printf("\n");
    }
 
  if( n < 0)
    {
      printf("\n Read Error \n");
    }
 
  return 0;
}

TCP Server:-

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>

 
int main(void)
{
  int listenfd = 0,connfd = 0;
  
  struct sockaddr_in serv_addr;
 
  char sendBuff[1025];  
  int numrv;  
 
  listenfd = socket(AF_INET, SOCK_STREAM, 0);
  printf("socket retrieve success\n");
  
  memset(&serv_addr, '0', sizeof(serv_addr));
  memset(sendBuff, '0', sizeof(sendBuff));
      
  serv_addr.sin_family = AF_INET;    
  serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); 
  serv_addr.sin_port = htons(5000);    
 
  bind(listenfd, (struct sockaddr*)&serv_addr,sizeof(serv_addr));
  
  if(listen(listenfd, 10) == -1){
      printf("Failed to listen\n");
      return -1;
  }     
  
  while(1)
    {      
      connfd = accept(listenfd, (struct sockaddr*)NULL ,NULL); 

// accept awaiting request
  
      strcpy(sendBuff, "Message from server");
      write(connfd, sendBuff, strlen(sendBuff));
 
      close(connfd);    
      sleep(1);
    } 
 
  return 0;
}









FOR UDP:-

UDP Client:-

#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>

#define BUFFSIZE 255
void Die(char *mess)
 { 
  perror(mess); 
exit(1); 
}

int main(int argc, char *argv[]) {
            int sock;
            struct sockaddr_in echoserver;
            struct sockaddr_in echoclient;
            char buffer[BUFFSIZE];
            unsigned int echolen, clientlen;
            int received = 0;

            if (argc != 4) 
            {
              fprintf(stderr, "USAGE: %s <server_ip> <word> <port>\n", argv[0]);
              exit(1);
            }

/* Create the UDP socket */
            if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
            {
              Die("Failed to create socket");
            }
            /* Construct the server sockaddr_in structure */
            memset(&echoserver, 0, sizeof(echoserver));       /* Clear struct */
            echoserver.sin_family = AF_INET;                  /* Internet/IP */
            echoserver.sin_addr.s_addr = inet_addr(argv[1]);  /* IP address */
            echoserver.sin_port = htons(atoi(argv[3]));       /* server port *

/* Send the word to the server */
            echolen = strlen(argv[2]);
            if (sendto(sock, argv[2], echolen, 0,
                       (struct sockaddr *) &echoserver,sizeof(echoserver)) != echolen) 
            {
              Die("Mismatch in number of sent bytes");
            }

/* Receive the word back from the server */
            fprintf(stdout, "Received: ");
            clientlen = sizeof(echoclient);
            if ((received = recvfrom(sock, buffer, BUFFSIZE, 0,(struct sockaddr *) &echoclient,&clientlen)) != echolen) 
           {
              Die("Mismatch in number of received bytes");
            }
/* Check that client and server are using same socket */
            if (echoserver.sin_addr.s_addr != echoclient.sin_addr.s_addr) 
           {
              Die("Received a packet from an unexpected server");
            }
            buffer[received] = '\0';        /* Assure null terminated string */
            fprintf(stdout, buffer);
            fprintf(stdout, "\n");
            close(sock);
            exit(0);
          }
                      
UDP Server:-

#include <stdio.h>
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdlib.h>
          #include <string.h>
          #include <unistd.h>
          #include <netinet/in.h>

          #define BUFFSIZE 255
          void Die(char *mess) 
         { 
                  perror(mess); exit(1);
 }

            int main(int argc, char *argv[])
 {
            int sock;
            struct sockaddr_in echoserver;
            struct sockaddr_in echoclient;
            char buffer[BUFFSIZE];
            unsigned int echolen, clientlen, serverlen;
            int received = 0;

            if (argc != 2) 
{
              fprintf(stderr, "USAGE: %s <port>\n", argv[0]);
              exit(1);
            }

/* Create the UDP socket */
          if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) 
{
            Die("Failed to create socket");
          }
          /* Construct the server sockaddr_in structure */
          memset(&echoserver, 0, sizeof(echoserver));       /* Clear struct */
          echoserver.sin_family = AF_INET;                  /* Internet/IP */
          echoserver.sin_addr.s_addr = htonl(INADDR_ANY);   /* Any IP address */
          echoserver.sin_port = htons(atoi(argv[1]));       /* server port */

          /* Bind the socket */
          serverlen = sizeof(echoserver);
          if (bind(sock, (struct sockaddr *) &echoserver, serverlen) < 0) {
            Die("Failed to bind server socket");
          }
 /* Run until cancelled */
            while (1) {
              /* Receive a message from the client */
              clientlen = sizeof(echoclient);
              if ((received = recvfrom(sock, buffer, BUFFSIZE, 0,
                                       (struct sockaddr *) &echoclient,
                                       &clientlen)) < 0) {
                printf("Failed to receive message");
              }
              fprintf(stderr,"Client connected: %s\n", inet_ntoa(echoclient.sin_addr));
              /* Send the message back to client */
              if (sendto(sock, buffer, received, 0,
                         (struct sockaddr *) &echoclient,
                         sizeof(echoclient)) != received) {
                Die("Mismatch in number of echo'd bytes");
              }
            }
          }



